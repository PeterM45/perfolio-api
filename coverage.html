
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/PeterM45/perfolio-api/cmd/api/app/app.go (0.0%)</option>
				
				<option value="file1">github.com/PeterM45/perfolio-api/cmd/api/app/router.go (0.0%)</option>
				
				<option value="file2">github.com/PeterM45/perfolio-api/cmd/api/main.go (0.0%)</option>
				
				<option value="file3">github.com/PeterM45/perfolio-api/internal/common/config/config.go (0.0%)</option>
				
				<option value="file4">github.com/PeterM45/perfolio-api/internal/common/interfaces/user_service.go (0.0%)</option>
				
				<option value="file5">github.com/PeterM45/perfolio-api/internal/common/middleware/auth.go (0.0%)</option>
				
				<option value="file6">github.com/PeterM45/perfolio-api/internal/common/middleware/logging.go (0.0%)</option>
				
				<option value="file7">github.com/PeterM45/perfolio-api/internal/platform/cache/cache.go (0.0%)</option>
				
				<option value="file8">github.com/PeterM45/perfolio-api/internal/platform/cache/memory.go (0.0%)</option>
				
				<option value="file9">github.com/PeterM45/perfolio-api/internal/platform/cache/redis.go (0.0%)</option>
				
				<option value="file10">github.com/PeterM45/perfolio-api/internal/platform/database/database.go (0.0%)</option>
				
				<option value="file11">github.com/PeterM45/perfolio-api/internal/user/handler/post_handler.go (0.0%)</option>
				
				<option value="file12">github.com/PeterM45/perfolio-api/internal/user/handler/user_handler.go (0.0%)</option>
				
				<option value="file13">github.com/PeterM45/perfolio-api/internal/user/handler/widget_handler.go (0.0%)</option>
				
				<option value="file14">github.com/PeterM45/perfolio-api/internal/user/repository/post_repo.go (0.0%)</option>
				
				<option value="file15">github.com/PeterM45/perfolio-api/internal/user/repository/user_repo.go (0.0%)</option>
				
				<option value="file16">github.com/PeterM45/perfolio-api/internal/user/repository/widget_repo.go (0.0%)</option>
				
				<option value="file17">github.com/PeterM45/perfolio-api/internal/user/service/post_service.go (0.0%)</option>
				
				<option value="file18">github.com/PeterM45/perfolio-api/internal/user/service/widget_service.go (0.0%)</option>
				
				<option value="file19">github.com/PeterM45/perfolio-api/pkg/apperrors/errors.go (0.0%)</option>
				
				<option value="file20">github.com/PeterM45/perfolio-api/pkg/logger/logger.go (0.0%)</option>
				
				<option value="file21">github.com/PeterM45/perfolio-api/pkg/validator/validator.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package app

import (
        "context"
        "fmt"
        "net/http"

        "github.com/PeterM45/perfolio-api/internal/common/config"
        "github.com/PeterM45/perfolio-api/internal/common/interfaces"
        "github.com/PeterM45/perfolio-api/internal/common/middleware"
        "github.com/PeterM45/perfolio-api/internal/platform/cache"
        "github.com/PeterM45/perfolio-api/internal/platform/database"

        contentHandler "github.com/PeterM45/perfolio-api/internal/user/handler"
        userHandler "github.com/PeterM45/perfolio-api/internal/user/handler"
        contentRepo "github.com/PeterM45/perfolio-api/internal/user/repository"
        userRepo "github.com/PeterM45/perfolio-api/internal/user/repository"
        contentService "github.com/PeterM45/perfolio-api/internal/user/service"
        "github.com/PeterM45/perfolio-api/pkg/logger"
)

// Application represents the API application
type Application struct {
        config *config.Config
        server *http.Server
        logger logger.Logger
        db     *database.DB
        cache  cache.Cache
}

// New creates a new application
func New(cfg *config.Config, log logger.Logger) (*Application, error) <span class="cov0" title="0">{
        // Initialize database
        dbConfig := database.Config{
                Host:            cfg.Database.Host,
                Port:            cfg.Database.Port,
                User:            cfg.Database.User,
                Password:        cfg.Database.Password,
                Name:            cfg.Database.Name,
                SSLMode:         cfg.Database.SSLMode,
                MaxOpenConns:    cfg.Database.MaxOpenConns,
                MaxIdleConns:    cfg.Database.MaxIdleConns,
                ConnMaxLifetime: cfg.Database.ConnMaxLifetime,
        }
        db, err := database.NewPostgresDB(dbConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        // Initialize cache
        <span class="cov0" title="0">var cacheClient cache.Cache
        if cfg.Cache.Type == "redis" </span><span class="cov0" title="0">{
                redisCache, err := cache.NewRedisCache(cfg.Cache.RedisURL)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warn().Err(err).Msg("Failed to connect to Redis, falling back to in-memory cache")
                        cacheClient = cache.NewInMemoryCache(cfg.Cache.DefaultTTL)
                }</span> else<span class="cov0" title="0"> {
                        cacheClient = redisCache
                }</span>
        } else<span class="cov0" title="0"> {
                cacheClient = cache.NewInMemoryCache(cfg.Cache.DefaultTTL)
        }</span>

        // Initialize repositories
        <span class="cov0" title="0">userRepository := userRepo.NewUserRepository(db)
        postRepository := contentRepo.NewPostRepository(db)
        widgetRepository := contentRepo.NewWidgetRepository(db)

        // Initialize auth middleware
        authMiddleware := middleware.NewAuthMiddleware(cfg.Auth.ClerkSecretKey)

        // Initialize services
        userSvc := interfaces.NewUserService(userRepository, cacheClient, log)
        postSvc := contentService.NewPostService(postRepository, userSvc, cacheClient, log)
        widgetSvc := contentService.NewWidgetService(widgetRepository, userSvc, cacheClient, log)

        // Initialize handlers
        userHandler := userHandler.NewUserHandler(userSvc, log)
        postHandler := contentHandler.NewPostHandler(postSvc, log)
        widgetHandler := contentHandler.NewWidgetHandler(widgetSvc, log)

        // Initialize router
        router := NewRouter(userHandler, postHandler, widgetHandler, authMiddleware, log)

        // Create server
        server := &amp;http.Server{
                Addr:         fmt.Sprintf(":%d", cfg.Server.Port),
                Handler:      router,
                ReadTimeout:  cfg.Server.ReadTimeout,
                WriteTimeout: cfg.Server.WriteTimeout,
                IdleTimeout:  cfg.Server.IdleTimeout,
        }

        return &amp;Application{
                config: cfg,
                server: server,
                logger: log,
                db:     db,
                cache:  cacheClient,
        }, nil</span>
}

// Start starts the HTTP server
func (a *Application) Start() error <span class="cov0" title="0">{
        return a.server.ListenAndServe()
}</span>

// Stop gracefully shuts down the server
func (a *Application) Stop(ctx context.Context) error <span class="cov0" title="0">{
        a.logger.Info().Msg("Closing database connections...")
        if err := a.db.Close(); err != nil </span><span class="cov0" title="0">{
                a.logger.Error().Err(err).Msg("Error closing database connections")
        }</span>

        // If Redis cache, close it
        <span class="cov0" title="0">if _, ok := a.cache.(*cache.RedisCache); ok </span><span class="cov0" title="0">{
                a.logger.Info().Msg("Redis cache is being used, but no close method is available.")
        }</span>

        <span class="cov0" title="0">a.logger.Info().Msg("Shutting down HTTP server...")
        return a.server.Shutdown(ctx)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "time"

        "github.com/PeterM45/perfolio-api/internal/common/middleware"
        contentHandler "github.com/PeterM45/perfolio-api/internal/user/handler"
        userHandler "github.com/PeterM45/perfolio-api/internal/user/handler"
        "github.com/PeterM45/perfolio-api/pkg/logger"
        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
)

// NewRouter sets up the HTTP router with all routes
func NewRouter(
        userHandler *userHandler.UserHandler,
        postHandler *contentHandler.PostHandler,
        widgetHandler *contentHandler.WidgetHandler,
        authMiddleware *middleware.AuthMiddleware,
        log logger.Logger,
) *gin.Engine <span class="cov0" title="0">{
        // Set Gin mode based on environment
        gin.SetMode(gin.ReleaseMode)

        // Create router
        router := gin.New()

        // Apply middleware
        router.Use(middleware.RequestIDMiddleware())
        router.Use(middleware.LoggerMiddleware(log))
        router.Use(gin.Recovery())

        // Configure CORS
        router.Use(cors.New(cors.Config{
                AllowOrigins:     []string{"https://*.perfolio.com", "http://localhost:3000"},
                AllowMethods:     []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"},
                AllowHeaders:     []string{"Origin", "Content-Type", "Accept", "Authorization", "X-Request-ID"},
                ExposeHeaders:    []string{"Content-Length", "X-Request-ID"},
                AllowCredentials: true,
                MaxAge:           12 * time.Hour,
        }))

        // Health check route
        router.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"status": "ok"})
        }</span>)

        // API v1 routes
        <span class="cov0" title="0">v1 := router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // Register user routes
                userHandler.RegisterRoutes(v1)

                // Register post routes
                postHandler.RegisterRoutes(v1)

                // Register widget routes
                widgetHandler.RegisterRoutes(v1)

                // Webhook routes
                webhooks := v1.Group("/webhooks")
                </span><span class="cov0" title="0">{
                        // Clerk webhook route
                        clerk := webhooks.Group("/clerk").Use(authMiddleware.ClerkWebhookHandler())
                        </span><span class="cov0" title="0">{
                                clerk.POST("/", func(c *gin.Context) </span><span class="cov0" title="0">{
                                        // Process Clerk webhook event
                                        c.JSON(200, gin.H{"status": "webhook received"})
                                }</span>)
                        }
                }
        }

        <span class="cov0" title="0">return router</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "flag"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        app "github.com/PeterM45/perfolio-api/cmd/api/app"
        "github.com/PeterM45/perfolio-api/internal/common/config"
        "github.com/PeterM45/perfolio-api/pkg/logger"
)

func main() <span class="cov0" title="0">{
        // Parse command line flags
        // configFile := flag.String("config", "./configs/config.yaml", "Path to config file")
        flag.Parse()

        // Initialize logger
        log := logger.NewLogger("info")

        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Failed to load configuration")
        }</span>

        // Create application
        <span class="cov0" title="0">application, err := app.New(cfg, log)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Failed to create application")
        }</span>

        // Start server in a goroutine
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                log.Info().Int("port", cfg.Server.Port).Msg("Starting Perfolio API server")
                if err := application.Start(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatal().Err(err).Msg("Failed to start server")
                }</span>
        }()

        // Wait for interrupt signal
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        s := &lt;-quit
        log.Info().Str("signal", s.String()).Msg("Shutting down server...")

        // Create context with timeout for shutdown
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        // Attempt graceful shutdown
        if err := application.Stop(ctx); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Server forced to shutdown")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">log.Info().Msg("Server gracefully stopped")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "time"

        "github.com/spf13/viper"
)

// Config holds all configuration for the application
type Config struct {
        Server struct {
                Port         int           `mapstructure:"port"`
                ReadTimeout  time.Duration `mapstructure:"read_timeout"`
                WriteTimeout time.Duration `mapstructure:"write_timeout"`
                IdleTimeout  time.Duration `mapstructure:"idle_timeout"`
        } `mapstructure:"server"`

        Database struct {
                Host            string        `mapstructure:"host"`
                Port            int           `mapstructure:"port"`
                User            string        `mapstructure:"user"`
                Password        string        `mapstructure:"password"`
                Name            string        `mapstructure:"name"`
                SSLMode         string        `mapstructure:"ssl_mode"`
                MaxOpenConns    int           `mapstructure:"max_open_conns"`
                MaxIdleConns    int           `mapstructure:"max_idle_conns"`
                ConnMaxLifetime time.Duration `mapstructure:"conn_max_lifetime"`
        } `mapstructure:"database"`

        Auth struct {
                JWTSecret      string        `mapstructure:"jwt_secret"`
                TokenExpiry    time.Duration `mapstructure:"token_expiry"`
                ClerkSecretKey string        `mapstructure:"clerk_secret_key"`
        } `mapstructure:"auth"`

        Cache struct {
                Type       string        `mapstructure:"type"`
                RedisURL   string        `mapstructure:"redis_url"`
                DefaultTTL time.Duration `mapstructure:"default_ttl"`
        } `mapstructure:"cache"`

        LogLevel string `mapstructure:"log_level"`
}

// Load loads configuration from environment variables and config files
func Load() (*Config, error) <span class="cov0" title="0">{
        viper.SetConfigName("config")
        viper.SetConfigType("yaml")
        viper.AddConfigPath(".")
        viper.AddConfigPath("./configs")

        viper.AutomaticEnv()

        // Default values
        viper.SetDefault("server.port", 8080)
        viper.SetDefault("server.read_timeout", time.Second*10)
        viper.SetDefault("server.write_timeout", time.Second*10)
        viper.SetDefault("server.idle_timeout", time.Second*60)

        viper.SetDefault("database.max_open_conns", 25)
        viper.SetDefault("database.max_idle_conns", 10)
        viper.SetDefault("database.conn_max_lifetime", time.Minute*5)

        viper.SetDefault("cache.type", "memory")
        viper.SetDefault("cache.default_ttl", time.Minute*5)

        viper.SetDefault("log_level", "info")

        // Read configuration
        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                // Config file is optional
                if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">var config Config
        if err := viper.Unmarshal(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package interfaces

import (
        "context"
        "fmt"
        "time"

        "github.com/PeterM45/perfolio-api/internal/common/model"
        "github.com/PeterM45/perfolio-api/internal/platform/cache"
        "github.com/PeterM45/perfolio-api/internal/user/repository"
        "github.com/PeterM45/perfolio-api/pkg/apperrors"
        "github.com/PeterM45/perfolio-api/pkg/logger"
        "github.com/PeterM45/perfolio-api/pkg/validator"
)

// UserService defines methods for user business logic
type UserService interface {
        GetUserByID(ctx context.Context, id string) (*model.User, error)
        GetUserByUsername(ctx context.Context, username string) (*model.User, error)
        CreateUser(ctx context.Context, req *model.CreateUserRequest) (*model.User, error)
        UpdateUser(ctx context.Context, id string, req *model.UpdateUserRequest) (*model.User, error)
        SearchUsers(ctx context.Context, query string, limit int) ([]*model.User, error)

        ToggleFollow(ctx context.Context, req *model.FollowRequest, followerID string) error
        IsFollowing(ctx context.Context, followerID, followingID string) (bool, error)
        GetProfileStats(ctx context.Context, userID string) (*model.ProfileStatsResponse, error)
        GetFollowers(ctx context.Context, userID string, limit, offset int) ([]*model.User, error)
        GetFollowing(ctx context.Context, userID string, limit, offset int) ([]*model.User, error)
}

type userService struct {
        repo      repository.UserRepository
        cache     cache.Cache
        validator validator.Validator
        logger    logger.Logger
}

// NewUserService creates a new UserService
func NewUserService(repo repository.UserRepository, cache cache.Cache, logger logger.Logger) UserService <span class="cov0" title="0">{
        return &amp;userService{
                repo:      repo,
                cache:     cache,
                validator: validator.NewValidator(),
                logger:    logger,
        }
}</span>

// GetUserByID retrieves a user by ID
func (s *userService) GetUserByID(ctx context.Context, id string) (*model.User, error) <span class="cov0" title="0">{
        if id == "" </span><span class="cov0" title="0">{
                return nil, apperrors.BadRequest("user ID cannot be empty")
        }</span>

        // Check cache first
        <span class="cov0" title="0">cacheKey := fmt.Sprintf("user:%s", id)
        if cachedUser, found := s.cache.Get(cacheKey); found </span><span class="cov0" title="0">{
                s.logger.Debug().Str("user_id", id).Msg("User found in cache")
                return cachedUser.(*model.User), nil
        }</span>

        // Get from repository
        <span class="cov0" title="0">user, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store in cache
        <span class="cov0" title="0">s.cache.Set(cacheKey, user, 5*time.Minute)

        return user, nil</span>
}

// GetUserByUsername retrieves a user by username
func (s *userService) GetUserByUsername(ctx context.Context, username string) (*model.User, error) <span class="cov0" title="0">{
        if username == "" </span><span class="cov0" title="0">{
                return nil, apperrors.BadRequest("username cannot be empty")
        }</span>

        // Check cache first
        <span class="cov0" title="0">cacheKey := fmt.Sprintf("user:username:%s", username)
        if cachedUser, found := s.cache.Get(cacheKey); found </span><span class="cov0" title="0">{
                s.logger.Debug().Str("username", username).Msg("User found in cache by username")
                return cachedUser.(*model.User), nil
        }</span>

        // Get from repository
        <span class="cov0" title="0">user, err := s.repo.GetByUsername(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store in cache
        <span class="cov0" title="0">s.cache.Set(cacheKey, user, 5*time.Minute)
        s.cache.Set(fmt.Sprintf("user:%s", user.ID), user, 5*time.Minute)

        return user, nil</span>
}

// CreateUser creates a new user
func (s *userService) CreateUser(ctx context.Context, req *model.CreateUserRequest) (*model.User, error) <span class="cov0" title="0">{
        if err := s.validator.Validate(req); err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.BadRequest(err.Error())
        }</span>

        // Check if username is available
        <span class="cov0" title="0">existingUser, err := s.repo.GetByUsername(ctx, req.Username)
        if err == nil &amp;&amp; existingUser != nil </span><span class="cov0" title="0">{
                return nil, apperrors.BadRequest("username already taken")
        }</span>

        // Convert to user model
        <span class="cov0" title="0">user := &amp;model.User{
                ID:           req.ID,
                Email:        req.Email,
                Username:     req.Username,
                FirstName:    req.FirstName,
                LastName:     req.LastName,
                Bio:          req.Bio,
                AuthProvider: req.AuthProvider,
                ImageURL:     req.ImageURL,
                IsActive:     true,
        }

        // Save to repository
        if err := s.repo.Create(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// UpdateUser updates an existing user
func (s *userService) UpdateUser(ctx context.Context, id string, req *model.UpdateUserRequest) (*model.User, error) <span class="cov0" title="0">{
        if id == "" </span><span class="cov0" title="0">{
                return nil, apperrors.BadRequest("user ID cannot be empty")
        }</span>

        <span class="cov0" title="0">if err := s.validator.Validate(req); err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.BadRequest(err.Error())
        }</span>

        // Check if user exists
        <span class="cov0" title="0">existingUser, err := s.GetUserByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Build update map
        <span class="cov0" title="0">updates := make(map[string]interface{})

        if req.Username != nil </span><span class="cov0" title="0">{
                // Check if new username is available
                if *req.Username != existingUser.Username </span><span class="cov0" title="0">{
                        user, err := s.repo.GetByUsername(ctx, *req.Username)
                        if err == nil &amp;&amp; user != nil </span><span class="cov0" title="0">{
                                return nil, apperrors.BadRequest("username already taken")
                        }</span>
                        <span class="cov0" title="0">updates["username"] = *req.Username</span>
                }
        }

        // Add other fields if provided
        <span class="cov0" title="0">if req.FirstName != nil </span><span class="cov0" title="0">{
                updates["firstName"] = *req.FirstName
        }</span>

        <span class="cov0" title="0">if req.LastName != nil </span><span class="cov0" title="0">{
                updates["lastName"] = *req.LastName
        }</span>

        <span class="cov0" title="0">if req.Bio != nil </span><span class="cov0" title="0">{
                updates["bio"] = *req.Bio
        }</span>

        <span class="cov0" title="0">if req.ImageURL != nil </span><span class="cov0" title="0">{
                updates["imageUrl"] = *req.ImageURL
        }</span>

        <span class="cov0" title="0">if req.IsActive != nil </span><span class="cov0" title="0">{
                updates["isActive"] = *req.IsActive
        }</span>

        // Only update if there are changes
        <span class="cov0" title="0">if len(updates) &gt; 0 </span><span class="cov0" title="0">{
                err = s.repo.Update(ctx, id, updates)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Invalidate cache
                <span class="cov0" title="0">s.cache.Delete(fmt.Sprintf("user:%s", id))
                if req.Username != nil </span><span class="cov0" title="0">{
                        s.cache.Delete(fmt.Sprintf("user:username:%s", existingUser.Username))
                }</span>

                // Get updated user
                <span class="cov0" title="0">return s.repo.GetByID(ctx, id)</span>
        }

        <span class="cov0" title="0">return existingUser, nil</span>
}

// SearchUsers searches for users
func (s *userService) SearchUsers(ctx context.Context, query string, limit int) ([]*model.User, error) <span class="cov0" title="0">{
        if query == "" </span><span class="cov0" title="0">{
                return nil, apperrors.BadRequest("search query cannot be empty")
        }</span>

        <span class="cov0" title="0">if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        <span class="cov0" title="0">return s.repo.Search(ctx, query, limit)</span>
}

// ToggleFollow toggles a follow relationship
func (s *userService) ToggleFollow(ctx context.Context, req *model.FollowRequest, followerID string) error <span class="cov0" title="0">{
        if err := s.validator.Validate(req); err != nil </span><span class="cov0" title="0">{
                return apperrors.BadRequest(err.Error())
        }</span>

        // Can't follow yourself
        <span class="cov0" title="0">if followerID == req.FollowingID </span><span class="cov0" title="0">{
                return apperrors.BadRequest("cannot follow yourself")
        }</span>

        // Verify both users exist
        <span class="cov0" title="0">if _, err := s.GetUserByID(ctx, followerID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if _, err := s.GetUserByID(ctx, req.FollowingID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Perform requested action
        <span class="cov0" title="0">var err error
        if req.Action == "follow" </span><span class="cov0" title="0">{
                err = s.repo.AddFollow(ctx, followerID, req.FollowingID)
        }</span> else<span class="cov0" title="0"> {
                err = s.repo.RemoveFollow(ctx, followerID, req.FollowingID)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Invalidate caches
        <span class="cov0" title="0">s.cache.Delete(fmt.Sprintf("follows:%s:%s", followerID, req.FollowingID))
        s.cache.Delete(fmt.Sprintf("follower_count:%s", req.FollowingID))
        s.cache.Delete(fmt.Sprintf("following_count:%s", followerID))

        return nil</span>
}

// IsFollowing checks if a user is following another
func (s *userService) IsFollowing(ctx context.Context, followerID, followingID string) (bool, error) <span class="cov0" title="0">{
        // Check cache first
        cacheKey := fmt.Sprintf("follows:%s:%s", followerID, followingID)
        if cachedResult, found := s.cache.Get(cacheKey); found </span><span class="cov0" title="0">{
                return cachedResult.(bool), nil
        }</span>

        <span class="cov0" title="0">isFollowing, err := s.repo.IsFollowing(ctx, followerID, followingID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Cache the result
        <span class="cov0" title="0">s.cache.Set(cacheKey, isFollowing, 5*time.Minute)

        return isFollowing, nil</span>
}

// GetProfileStats gets follower and following counts
func (s *userService) GetProfileStats(ctx context.Context, userID string) (*model.ProfileStatsResponse, error) <span class="cov0" title="0">{
        // Check if user exists
        if _, err := s.GetUserByID(ctx, userID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get follower count (with cache)
        <span class="cov0" title="0">var followerCount int
        followerCacheKey := fmt.Sprintf("follower_count:%s", userID)

        if cachedCount, found := s.cache.Get(followerCacheKey); found </span><span class="cov0" title="0">{
                followerCount = cachedCount.(int)
        }</span> else<span class="cov0" title="0"> {
                var err error
                followerCount, err = s.repo.GetFollowerCount(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">s.cache.Set(followerCacheKey, followerCount, 5*time.Minute)</span>
        }

        // Get following count (with cache)
        <span class="cov0" title="0">var followingCount int
        followingCacheKey := fmt.Sprintf("following_count:%s", userID)

        if cachedCount, found := s.cache.Get(followingCacheKey); found </span><span class="cov0" title="0">{
                followingCount = cachedCount.(int)
        }</span> else<span class="cov0" title="0"> {
                var err error
                followingCount, err = s.repo.GetFollowingCount(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">s.cache.Set(followingCacheKey, followingCount, 5*time.Minute)</span>
        }

        <span class="cov0" title="0">return &amp;model.ProfileStatsResponse{
                FollowerCount:  followerCount,
                FollowingCount: followingCount,
        }, nil</span>
}

// GetFollowers gets users who follow the given user
func (s *userService) GetFollowers(ctx context.Context, userID string, limit, offset int) ([]*model.User, error) <span class="cov0" title="0">{
        // Check if user exists
        if _, err := s.GetUserByID(ctx, userID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.repo.GetFollowers(ctx, userID, limit, offset)</span>
}

// GetFollowing gets users the given user follows
func (s *userService) GetFollowing(ctx context.Context, userID string, limit, offset int) ([]*model.User, error) <span class="cov0" title="0">{
        // Check if user exists
        if _, err := s.GetUserByID(ctx, userID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.repo.GetFollowing(ctx, userID, limit, offset)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package middleware

import (
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
)

// AuthMiddleware handles authentication with Clerk
type AuthMiddleware struct {
        clerkSecretKey string
}

// NewAuthMiddleware creates a new auth middleware
func NewAuthMiddleware(clerkSecretKey string) *AuthMiddleware <span class="cov0" title="0">{
        return &amp;AuthMiddleware{
                clerkSecretKey: clerkSecretKey,
        }
}</span>

// Authenticate verifies the JWT token from Clerk
func (m *AuthMiddleware) Authenticate() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Get Authorization header
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "authorization header is required"})
                        c.Abort()
                        return
                }</span>

                // Check if it starts with "Bearer "
                <span class="cov0" title="0">parts := strings.Split(authHeader, " ")
                if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid authorization header format"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">tokenString := parts[1]
                if tokenString == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "token is required"})
                        c.Abort()
                        return
                }</span>

                // Parse and validate the token
                <span class="cov0" title="0">token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        // Validate the alg
                        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                        }</span>

                        // Return the key for validation
                        <span class="cov0" title="0">return []byte(m.clerkSecretKey), nil</span>
                })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid token: " + err.Error()})
                        c.Abort()
                        return
                }</span>

                // Check if the token is valid
                <span class="cov0" title="0">if !token.Valid </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid token"})
                        c.Abort()
                        return
                }</span>

                // Extract claims
                <span class="cov0" title="0">claims, ok := token.Claims.(jwt.MapClaims)
                if !ok </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid token claims"})
                        c.Abort()
                        return
                }</span>

                // Check expiration
                <span class="cov0" title="0">exp, ok := claims["exp"].(float64)
                if !ok </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid token expiration"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">if time.Now().Unix() &gt; int64(exp) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "token expired"})
                        c.Abort()
                        return
                }</span>

                // Extract user ID from claims (adjust based on Clerk's JWT format)
                <span class="cov0" title="0">sub, ok := claims["sub"].(string)
                if !ok || sub == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user ID in token"})
                        c.Abort()
                        return
                }</span>

                // Set the user ID in context
                <span class="cov0" title="0">c.Set("userID", sub)
                c.Next()</span>
        }
}

// Optional middleware to check if user is authenticated
// but doesn't block if they're not
func (m *AuthMiddleware) OptionalAuthenticate() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Check if it starts with "Bearer "
                <span class="cov0" title="0">parts := strings.Split(authHeader, " ")
                if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                <span class="cov0" title="0">tokenString := parts[1]
                if tokenString == "" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Parse and validate the token
                <span class="cov0" title="0">token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        // Validate the alg
                        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                        }</span>

                        // Return the key for validation
                        <span class="cov0" title="0">return []byte(m.clerkSecretKey), nil</span>
                })

                <span class="cov0" title="0">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Extract claims
                <span class="cov0" title="0">claims, ok := token.Claims.(jwt.MapClaims)
                if !ok </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Check expiration
                <span class="cov0" title="0">exp, ok := claims["exp"].(float64)
                if !ok || time.Now().Unix() &gt; int64(exp) </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Extract user ID from claims
                <span class="cov0" title="0">sub, ok := claims["sub"].(string)
                if !ok || sub == "" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Set the user ID in context
                <span class="cov0" title="0">c.Set("userID", sub)
                c.Next()</span>
        }
}

// ClerkWebhookHandler is a middleware to handle Clerk webhooks
// This verifies the webhook signature from Clerk
func (m *AuthMiddleware) ClerkWebhookHandler() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                svix_id := c.GetHeader("svix-id")
                svix_timestamp := c.GetHeader("svix-timestamp")
                svix_signature := c.GetHeader("svix-signature")

                // Verify webhook
                if svix_id == "" || svix_timestamp == "" || svix_signature == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "missing svix headers"})
                        c.Abort()
                        return
                }</span>

                // TODO: Implement actual signature verification if needed
                // This is simplified for now and should be expanded based on Clerk's docs
                // https://clerk.dev/docs/integrations/webhooks

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package middleware

import (
        "time"

        "github.com/PeterM45/perfolio-api/pkg/logger"
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// LoggerMiddleware logs HTTP requests
func LoggerMiddleware(log logger.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Start timer
                start := time.Now()

                // Get or generate request ID
                requestID := c.GetHeader("X-Request-ID")
                if requestID == "" </span><span class="cov0" title="0">{
                        requestID = uuid.New().String()
                        c.Request.Header.Set("X-Request-ID", requestID)
                }</span>

                // Set request ID in context
                <span class="cov0" title="0">c.Set("requestID", requestID)
                c.Header("X-Request-ID", requestID)

                // Process request
                c.Next()

                // After request
                latency := time.Since(start)
                statusCode := c.Writer.Status()
                clientIP := c.ClientIP()
                method := c.Request.Method
                path := c.Request.URL.Path
                query := c.Request.URL.RawQuery
                if query != "" </span><span class="cov0" title="0">{
                        path = path + "?" + query
                }</span>
                <span class="cov0" title="0">userID, _ := c.Get("userID")

                // Log the request
                event := log.Info()

                // Add failure level for errors
                if statusCode &gt;= 400 </span><span class="cov0" title="0">{
                        event = log.Warn()
                }</span>
                <span class="cov0" title="0">if statusCode &gt;= 500 </span><span class="cov0" title="0">{
                        event = log.Error()
                }</span>

                // Include all fields
                <span class="cov0" title="0">event = event.
                        Str("requestID", requestID).
                        Str("method", method).
                        Str("path", path).
                        Str("clientIP", clientIP).
                        Int("statusCode", statusCode).
                        Dur("latency", latency)

                // Add user ID if available
                if userID != nil </span><span class="cov0" title="0">{
                        event = event.Str("userID", userID.(string))
                }</span>

                <span class="cov0" title="0">event.Msg("HTTP Request")</span>
        }
}

// RequestIDMiddleware adds a request ID to each request
func RequestIDMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                requestID := c.GetHeader("X-Request-ID")
                if requestID == "" </span><span class="cov0" title="0">{
                        requestID = uuid.New().String()
                }</span>

                <span class="cov0" title="0">c.Set("requestID", requestID)
                c.Header("X-Request-ID", requestID)
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package cache

import (
        "time"
)

// Cache defines the interface for cache functionality
type Cache interface {
        Get(key string) (interface{}, bool)
        Set(key string, value interface{}, ttl time.Duration)
        Delete(key string)
        Clear()
}

// Factory function to create the right cache implementation
func NewCache(cacheType string, options ...interface{}) Cache <span class="cov0" title="0">{
        switch cacheType </span>{
        case "redis":<span class="cov0" title="0">
                if len(options) &gt; 0 </span><span class="cov0" title="0">{
                        if redisURL, ok := options[0].(string); ok </span><span class="cov0" title="0">{
                                cache, err := NewRedisCache(redisURL)
                                if err != nil </span><span class="cov0" title="0">{
                                        return NewInMemoryCache(5 * time.Minute) // Fallback to in-memory cache on error
                                }</span>
                                <span class="cov0" title="0">return cache</span>
                        }
                }
                <span class="cov0" title="0">cache, err := NewRedisCache("localhost:6379")
                if err != nil </span><span class="cov0" title="0">{
                        return NewInMemoryCache(5 * time.Minute) // Fallback to in-memory cache on error
                }</span>
                <span class="cov0" title="0">return cache</span>
        }
        <span class="cov0" title="0">return NewInMemoryCache(5 * time.Minute)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package cache

import (
        "sync"
        "time"
)

// item represents a cached item with expiration
type item struct {
        value      interface{}
        expiration int64
}

// InMemoryCache is a simple in-memory cache implementation
type InMemoryCache struct {
        items map[string]item
        mu    sync.RWMutex
        ttl   time.Duration
}

// NewInMemoryCache creates a new in-memory cache
func NewInMemoryCache(defaultTTL time.Duration) *InMemoryCache <span class="cov0" title="0">{
        cache := &amp;InMemoryCache{
                items: make(map[string]item),
                ttl:   defaultTTL,
        }
        go cache.cleanupRoutine()
        return cache
}</span>

// Get retrieves a value from the cache
func (c *InMemoryCache) Get(key string) (interface{}, bool) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        item, found := c.items[key]
        if !found </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Check if item has expired
        <span class="cov0" title="0">if item.expiration &gt; 0 &amp;&amp; item.expiration &lt; time.Now().UnixNano() </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">return item.value, true</span>
}

// Set adds a value to the cache
func (c *InMemoryCache) Set(key string, value interface{}, ttl time.Duration) <span class="cov0" title="0">{
        var expiration int64

        if ttl == 0 </span><span class="cov0" title="0">{
                ttl = c.ttl
        }</span>

        <span class="cov0" title="0">if ttl &gt; 0 </span><span class="cov0" title="0">{
                expiration = time.Now().Add(ttl).UnixNano()
        }</span>

        <span class="cov0" title="0">c.mu.Lock()
        c.items[key] = item{
                value:      value,
                expiration: expiration,
        }
        c.mu.Unlock()</span>
}

// Delete removes a value from the cache
func (c *InMemoryCache) Delete(key string) <span class="cov0" title="0">{
        c.mu.Lock()
        delete(c.items, key)
        c.mu.Unlock()
}</span>

// Clear removes all values from the cache
func (c *InMemoryCache) Clear() <span class="cov0" title="0">{
        c.mu.Lock()
        c.items = make(map[string]item)
        c.mu.Unlock()
}</span>

// cleanupRoutine periodically cleans up expired items
func (c *InMemoryCache) cleanupRoutine() <span class="cov0" title="0">{
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                now := time.Now().UnixNano()

                c.mu.Lock()
                for k, v := range c.items </span><span class="cov0" title="0">{
                        if v.expiration &gt; 0 &amp;&amp; v.expiration &lt; now </span><span class="cov0" title="0">{
                                delete(c.items, k)
                        }</span>
                }
                <span class="cov0" title="0">c.mu.Unlock()</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cache

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/go-redis/redis/v8"
)

// RedisCache is a Redis-based cache implementation
type RedisCache struct {
        client *redis.Client
        ctx    context.Context
}

// NewRedisCache creates a new Redis cache
func NewRedisCache(redisURL string) (*RedisCache, error) <span class="cov0" title="0">{
        client := redis.NewClient(&amp;redis.Options{
                Addr: redisURL,
        })

        // Check if the client is able to connect to Redis
        _, err := client.Ping(context.Background()).Result()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to Redis: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;RedisCache{
                client: client,
                ctx:    context.Background(),
        }, nil</span>
}

// Get retrieves a value from Redis
func (c *RedisCache) Get(key string) (interface{}, bool) <span class="cov0" title="0">{
        val, err := c.client.Get(c.ctx, key).Result()
        if err == redis.Nil </span><span class="cov0" title="0">{
                return nil, false
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">var result interface{}
        if err := json.Unmarshal([]byte(val), &amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">return result, true</span>
}

// Set adds a value to Redis
func (c *RedisCache) Set(key string, value interface{}, ttl time.Duration) <span class="cov0" title="0">{
        jsonValue, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">c.client.Set(c.ctx, key, jsonValue, ttl)</span>
}

// Delete removes a value from Redis
func (c *RedisCache) Delete(key string) <span class="cov0" title="0">{
        c.client.Del(c.ctx, key)
}</span>

// Clear removes all values with a specific prefix
// Note: Redis doesn't have a direct "clear all" for a namespace without using KEYS
// which is not recommended for production
func (c *RedisCache) Clear() {<span class="cov0" title="0">
        // For full clear, this would be
        // c.client.FlushAll(c.ctx)
        // But that's too destructive for shared Redis instances

        // In a real application, consider using key prefixes and scanning
        // for more selective clearing
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "time"

        _ "github.com/jackc/pgx/v5/stdlib" // PostgreSQL driver
)

// DB wraps *sql.DB
type DB struct {
        *sql.DB
}

// Config holds database configuration
type Config struct {
        Host            string
        Port            int
        User            string
        Password        string
        Name            string
        SSLMode         string
        MaxOpenConns    int
        MaxIdleConns    int
        ConnMaxLifetime time.Duration
}

// NewPostgresDB creates a new database connection
func NewPostgresDB(config Config) (*DB, error) <span class="cov0" title="0">{
        connStr := fmt.Sprintf(
                "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                config.Host, config.Port, config.User, config.Password, config.Name, config.SSLMode,
        )

        // Open connection
        db, err := sql.Open("pgx", connStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("open database connection: %w", err)
        }</span>

        // Set connection pool parameters
        <span class="cov0" title="0">db.SetMaxOpenConns(config.MaxOpenConns)
        db.SetMaxIdleConns(config.MaxIdleConns)
        db.SetConnMaxLifetime(config.ConnMaxLifetime)

        // Verify connection
        if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ping database: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;DB{db}, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package handler

import (
        "errors"
        "net/http"
        "strconv"

        "github.com/PeterM45/perfolio-api/internal/common/model"
        "github.com/PeterM45/perfolio-api/internal/user/service"
        "github.com/PeterM45/perfolio-api/pkg/apperrors"
        "github.com/PeterM45/perfolio-api/pkg/logger"
        "github.com/gin-gonic/gin"
)

// PostHandler handles HTTP requests for posts
type PostHandler struct {
        service service.PostService
        logger  logger.Logger
}

// NewPostHandler creates a new PostHandler
func NewPostHandler(service service.PostService, logger logger.Logger) *PostHandler <span class="cov0" title="0">{
        return &amp;PostHandler{
                service: service,
                logger:  logger,
        }
}</span>

// RegisterRoutes registers routes for the post handler
func (h *PostHandler) RegisterRoutes(router *gin.RouterGroup) <span class="cov0" title="0">{
        posts := router.Group("/posts")
        </span><span class="cov0" title="0">{
                posts.GET("/:id", h.GetPost)
                posts.POST("/", h.CreatePost)
                posts.PUT("/:id", h.UpdatePost)
                posts.DELETE("/:id", h.DeletePost)
                posts.GET("/user/:userId", h.GetUserPosts)
                posts.GET("/feed", h.GetFeed)
        }</span>
}

// GetPost handles GET /posts/:id
func (h *PostHandler) GetPost(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")

        h.logger.Debug().Str("post_id", id).Msg("Getting post by ID")

        post, err := h.service.GetPostByID(c, id)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, post)</span>
}

// CreatePost handles POST /posts
func (h *PostHandler) CreatePost(c *gin.Context) <span class="cov0" title="0">{
        // Get authenticated user
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">var req model.CreatePostRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debug().
                Str("user_id", userID.(string)).
                Interface("request", req).
                Msg("Creating post")

        post, err := h.service.CreatePost(c, userID.(string), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, post)</span>
}

// UpdatePost handles PUT /posts/:id
func (h *PostHandler) UpdatePost(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")

        // Get authenticated user
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">var req model.UpdatePostRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debug().
                Str("post_id", id).
                Str("user_id", userID.(string)).
                Interface("request", req).
                Msg("Updating post")

        post, err := h.service.UpdatePost(c, id, userID.(string), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, post)</span>
}

// DeletePost handles DELETE /posts/:id
func (h *PostHandler) DeletePost(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")

        // Get authenticated user
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debug().
                Str("post_id", id).
                Str("user_id", userID.(string)).
                Msg("Deleting post")

        err := h.service.DeletePost(c, id, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"success": true})</span>
}

// GetUserPosts handles GET /posts/user/:userId
func (h *PostHandler) GetUserPosts(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("userId")

        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))

        h.logger.Debug().
                Str("user_id", userID).
                Int("limit", limit).
                Int("offset", offset).
                Msg("Getting user posts")

        posts, err := h.service.GetUserPosts(c, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"posts": posts})</span>
}

// GetFeed handles GET /posts/feed
func (h *PostHandler) GetFeed(c *gin.Context) <span class="cov0" title="0">{
        // Get authenticated user
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))

        h.logger.Debug().
                Str("user_id", userID.(string)).
                Int("limit", limit).
                Int("offset", offset).
                Msg("Getting feed")

        posts, err := h.service.GetFeed(c, userID.(string), limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"posts": posts})</span>
}

// handleError handles errors and returns appropriate HTTP responses
func (h *PostHandler) handleError(c *gin.Context, err error) <span class="cov0" title="0">{
        var appErr *apperrors.Error
        if errors.As(err, &amp;appErr) </span><span class="cov0" title="0">{
                switch appErr.Type() </span>{
                case apperrors.ErrTypeNotFound:<span class="cov0" title="0">
                        c.JSON(http.StatusNotFound, gin.H{"error": appErr.Error()})</span>
                case apperrors.ErrTypeBadRequest:<span class="cov0" title="0">
                        c.JSON(http.StatusBadRequest, gin.H{"error": appErr.Error()})</span>
                case apperrors.ErrTypeUnauthorized:<span class="cov0" title="0">
                        c.JSON(http.StatusUnauthorized, gin.H{"error": appErr.Error()})</span>
                case apperrors.ErrTypeForbidden:<span class="cov0" title="0">
                        c.JSON(http.StatusForbidden, gin.H{"error": appErr.Error()})</span>
                case apperrors.ErrTypeConflict:<span class="cov0" title="0">
                        c.JSON(http.StatusConflict, gin.H{"error": appErr.Error()})</span>
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Internal server error"})</span>
                }
                <span class="cov0" title="0">return</span>
        }

        // If not an AppError, treat as internal server error
        <span class="cov0" title="0">h.logger.Error().Err(err).Msg("Internal server error")
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Internal server error"})</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package handler

import (
        "errors"
        "net/http"
        "strconv"

        "github.com/PeterM45/perfolio-api/internal/common/interfaces"
        "github.com/PeterM45/perfolio-api/internal/common/model"
        "github.com/PeterM45/perfolio-api/pkg/apperrors"
        "github.com/PeterM45/perfolio-api/pkg/logger"
        "github.com/gin-gonic/gin"
)

// UserHandler handles HTTP requests for users
type UserHandler struct {
        service interfaces.UserService
        logger  logger.Logger
}

// NewUserHandler creates a new UserHandler
func NewUserHandler(service interfaces.UserService, logger logger.Logger) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{
                service: service,
                logger:  logger,
        }
}</span>

// RegisterRoutes registers routes for the user handler
func (h *UserHandler) RegisterRoutes(router *gin.RouterGroup) <span class="cov0" title="0">{
        users := router.Group("/users")
        </span><span class="cov0" title="0">{
                // Profile routes
                users.GET("/:id", h.GetUserByID)
                users.GET("/username/:username", h.GetUserByUsername)
                users.POST("/", h.CreateUser)
                users.PUT("/:id", h.UpdateUser)
                users.GET("/search", h.SearchUsers)

                // Follow routes
                users.POST("/:id/follow", h.ToggleFollow)
                users.GET("/:id/is-following/:targetId", h.IsFollowing)
                users.GET("/:id/stats", h.GetProfileStats)
                users.GET("/:id/followers", h.GetFollowers)
                users.GET("/:id/following", h.GetFollowing)
        }</span>
}

// GetUserByID handles GET /users/:id
func (h *UserHandler) GetUserByID(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")

        h.logger.Debug().Str("user_id", id).Msg("Getting user by ID")

        user, err := h.service.GetUserByID(c, id)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, user)</span>
}

// GetUserByUsername handles GET /users/username/:username
func (h *UserHandler) GetUserByUsername(c *gin.Context) <span class="cov0" title="0">{
        username := c.Param("username")

        h.logger.Debug().Str("username", username).Msg("Getting user by username")

        user, err := h.service.GetUserByUsername(c, username)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, user)</span>
}

// CreateUser handles POST /users
func (h *UserHandler) CreateUser(c *gin.Context) <span class="cov0" title="0">{
        var req model.CreateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debug().Interface("request", req).Msg("Creating user")

        user, err := h.service.CreateUser(c, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, user)</span>
}

// UpdateUser handles PUT /users/:id
func (h *UserHandler) UpdateUser(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")

        // Check authentication
        userID, exists := c.Get("userID")
        if !exists || userID.(string) != id </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "you can only update your own profile"})
                return
        }</span>

        <span class="cov0" title="0">var req model.UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debug().Str("user_id", id).Interface("request", req).Msg("Updating user")

        user, err := h.service.UpdateUser(c, id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, user)</span>
}

// SearchUsers handles GET /users/search
func (h *UserHandler) SearchUsers(c *gin.Context) <span class="cov0" title="0">{
        query := c.Query("q")
        if query == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "search query is required"})
                return
        }</span>

        <span class="cov0" title="0">limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))

        h.logger.Debug().Str("query", query).Int("limit", limit).Msg("Searching users")

        users, err := h.service.SearchUsers(c, query, limit)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"users": users})</span>
}

// ToggleFollow handles POST /users/:id/follow
func (h *UserHandler) ToggleFollow(c *gin.Context) <span class="cov0" title="0">{
        // Get authenticated user
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">var req model.FollowRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debug().
                Str("follower_id", userID.(string)).
                Str("following_id", req.FollowingID).
                Str("action", req.Action).
                Msg("Toggle follow")

        err := h.service.ToggleFollow(c, &amp;req, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"success": true})</span>
}

// IsFollowing handles GET /users/:id/is-following/:targetId
func (h *UserHandler) IsFollowing(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("id")
        targetID := c.Param("targetId")

        h.logger.Debug().
                Str("user_id", userID).
                Str("target_id", targetID).
                Msg("Checking if user is following target")

        isFollowing, err := h.service.IsFollowing(c, userID, targetID)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"isFollowing": isFollowing})</span>
}

// GetProfileStats handles GET /users/:id/stats
func (h *UserHandler) GetProfileStats(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("id")

        h.logger.Debug().Str("user_id", userID).Msg("Getting profile stats")

        stats, err := h.service.GetProfileStats(c, userID)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, stats)</span>
}

// GetFollowers handles GET /users/:id/followers
func (h *UserHandler) GetFollowers(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("id")

        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))

        h.logger.Debug().
                Str("user_id", userID).
                Int("limit", limit).
                Int("offset", offset).
                Msg("Getting followers")

        followers, err := h.service.GetFollowers(c, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"users": followers})</span>
}

// GetFollowing handles GET /users/:id/following
func (h *UserHandler) GetFollowing(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("id")

        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))

        h.logger.Debug().
                Str("user_id", userID).
                Int("limit", limit).
                Int("offset", offset).
                Msg("Getting following")

        following, err := h.service.GetFollowing(c, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"users": following})</span>
}

// handleError handles errors and returns appropriate HTTP responses
func (h *UserHandler) handleError(c *gin.Context, err error) <span class="cov0" title="0">{
        var appErr *apperrors.Error
        if errors.As(err, &amp;appErr) </span><span class="cov0" title="0">{
                switch appErr.Type() </span>{
                case apperrors.ErrTypeNotFound:<span class="cov0" title="0">
                        c.JSON(http.StatusNotFound, gin.H{"error": appErr.Error()})</span>
                case apperrors.ErrTypeBadRequest:<span class="cov0" title="0">
                        c.JSON(http.StatusBadRequest, gin.H{"error": appErr.Error()})</span>
                case apperrors.ErrTypeUnauthorized:<span class="cov0" title="0">
                        c.JSON(http.StatusUnauthorized, gin.H{"error": appErr.Error()})</span>
                case apperrors.ErrTypeForbidden:<span class="cov0" title="0">
                        c.JSON(http.StatusForbidden, gin.H{"error": appErr.Error()})</span>
                case apperrors.ErrTypeConflict:<span class="cov0" title="0">
                        c.JSON(http.StatusConflict, gin.H{"error": appErr.Error()})</span>
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Internal server error"})</span>
                }
                <span class="cov0" title="0">return</span>
        }

        // If not an AppError, treat as internal server error
        <span class="cov0" title="0">h.logger.Error().Err(err).Msg("Internal server error")
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Internal server error"})</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package handler

import (
        "errors"
        "net/http"

        "github.com/PeterM45/perfolio-api/internal/common/model"
        "github.com/PeterM45/perfolio-api/internal/user/service"
        "github.com/PeterM45/perfolio-api/pkg/apperrors"
        "github.com/PeterM45/perfolio-api/pkg/logger"
        "github.com/gin-gonic/gin"
)

// WidgetHandler handles HTTP requests for widgets
type WidgetHandler struct {
        service service.WidgetService
        logger  logger.Logger
}

// NewWidgetHandler creates a new WidgetHandler
func NewWidgetHandler(service service.WidgetService, logger logger.Logger) *WidgetHandler <span class="cov0" title="0">{
        return &amp;WidgetHandler{
                service: service,
                logger:  logger,
        }
}</span>

// RegisterRoutes registers routes for the widget handler
func (h *WidgetHandler) RegisterRoutes(router *gin.RouterGroup) <span class="cov0" title="0">{
        widgets := router.Group("/widgets")
        </span><span class="cov0" title="0">{
                widgets.GET("/:id", h.GetWidget)
                widgets.GET("/user/:userId", h.GetUserWidgets)
                widgets.POST("/", h.CreateWidget)
                widgets.PUT("/:id", h.UpdateWidget)
                widgets.DELETE("/:id", h.DeleteWidget)
                widgets.POST("/batch-update", h.BatchUpdateWidgets)
        }</span>
}

// GetWidget handles GET /widgets/:id
func (h *WidgetHandler) GetWidget(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")

        h.logger.Debug().Str("widget_id", id).Msg("Getting widget by ID")

        widget, err := h.service.GetWidgetByID(c, id)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, widget)</span>
}

// GetUserWidgets handles GET /widgets/user/:userId
func (h *WidgetHandler) GetUserWidgets(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("userId")

        h.logger.Debug().Str("user_id", userID).Msg("Getting user widgets")

        widgets, err := h.service.GetUserWidgets(c, userID)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"widgets": widgets})</span>
}

// CreateWidget handles POST /widgets
func (h *WidgetHandler) CreateWidget(c *gin.Context) <span class="cov0" title="0">{
        // Get authenticated user
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">var req model.CreateWidgetRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debug().
                Str("user_id", userID.(string)).
                Interface("request", req).
                Msg("Creating widget")

        widget, err := h.service.CreateWidget(c, userID.(string), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, widget)</span>
}

// UpdateWidget handles PUT /widgets/:id
func (h *WidgetHandler) UpdateWidget(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")

        // Get authenticated user
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">var req model.UpdateWidgetRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debug().
                Str("widget_id", id).
                Str("user_id", userID.(string)).
                Interface("request", req).
                Msg("Updating widget")

        widget, err := h.service.UpdateWidget(c, id, userID.(string), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, widget)</span>
}

// DeleteWidget handles DELETE /widgets/:id
func (h *WidgetHandler) DeleteWidget(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")

        // Get authenticated user
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debug().
                Str("widget_id", id).
                Str("user_id", userID.(string)).
                Msg("Deleting widget")

        err := h.service.DeleteWidget(c, id, userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"success": true})</span>
}

// BatchUpdateWidgets handles POST /widgets/batch-update
func (h *WidgetHandler) BatchUpdateWidgets(c *gin.Context) <span class="cov0" title="0">{
        // Get authenticated user
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">var req model.BatchUpdateWidgetsRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debug().
                Str("user_id", userID.(string)).
                Int("update_count", len(req.Updates)).
                Msg("Batch updating widgets")

        err := h.service.BatchUpdateWidgets(c, userID.(string), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"success": true})</span>
}

// handleError handles errors and returns appropriate HTTP responses
func (h *WidgetHandler) handleError(c *gin.Context, err error) <span class="cov0" title="0">{
        var appErr *apperrors.Error
        if errors.As(err, &amp;appErr) </span><span class="cov0" title="0">{
                switch appErr.Type() </span>{
                case apperrors.ErrTypeNotFound:<span class="cov0" title="0">
                        c.JSON(http.StatusNotFound, gin.H{"error": appErr.Error()})</span>
                case apperrors.ErrTypeBadRequest:<span class="cov0" title="0">
                        c.JSON(http.StatusBadRequest, gin.H{"error": appErr.Error()})</span>
                case apperrors.ErrTypeUnauthorized:<span class="cov0" title="0">
                        c.JSON(http.StatusUnauthorized, gin.H{"error": appErr.Error()})</span>
                case apperrors.ErrTypeForbidden:<span class="cov0" title="0">
                        c.JSON(http.StatusForbidden, gin.H{"error": appErr.Error()})</span>
                case apperrors.ErrTypeConflict:<span class="cov0" title="0">
                        c.JSON(http.StatusConflict, gin.H{"error": appErr.Error()})</span>
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Internal server error"})</span>
                }
                <span class="cov0" title="0">return</span>
        }

        // If not an AppError, treat as internal server error
        <span class="cov0" title="0">h.logger.Error().Err(err).Msg("Internal server error")
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Internal server error"})</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package repository

import (
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        "time"

        "github.com/PeterM45/perfolio-api/internal/common/model"
        "github.com/PeterM45/perfolio-api/internal/platform/database"
        "github.com/PeterM45/perfolio-api/pkg/apperrors"
        "github.com/google/uuid"
)

// PostRepository defines methods to interact with post data
type PostRepository interface {
        Create(ctx context.Context, post *model.Post) error
        GetByID(ctx context.Context, id string) (*model.Post, error)
        Update(ctx context.Context, post *model.Post) error
        Delete(ctx context.Context, id string) error
        GetByUserID(ctx context.Context, userID string, limit, offset int) ([]*model.Post, error)
        GetFeed(ctx context.Context, userIDs []string, limit, offset int) ([]*model.Post, error)
}

type postRepository struct {
        db *database.DB
}

// NewPostRepository creates a new PostRepository
func NewPostRepository(db *database.DB) PostRepository <span class="cov0" title="0">{
        return &amp;postRepository{
                db: db,
        }
}</span>

// Create adds a new post
func (r *postRepository) Create(ctx context.Context, post *model.Post) error <span class="cov0" title="0">{
        // Generate ID if not provided
        if post.ID == "" </span><span class="cov0" title="0">{
                post.ID = uuid.New().String()
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO post (
                        id, user_id, content, embed_urls, hashtags, 
                        visibility, created_at, updated_at
                ) VALUES (
                        $1, $2, $3, $4, $5, $6, $7, $7
                )
        `

        now := time.Now().UTC()
        post.CreatedAt = now

        // Convert string arrays to PostgreSQL arrays
        embedURLsJSON, err := json.Marshal(post.EmbedURLs)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal embed URLs: %w", err)
        }</span>

        <span class="cov0" title="0">hashtagsJSON, err := json.Marshal(post.Hashtags)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal hashtags: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = r.db.ExecContext(ctx, query,
                post.ID,
                post.UserID,
                post.Content,
                embedURLsJSON,
                hashtagsJSON,
                post.Visibility,
                now,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create post: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetByID fetches a post by ID
func (r *postRepository) GetByID(ctx context.Context, id string) (*model.Post, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        p.id, p.user_id, p.content, p.embed_urls, p.hashtags, 
                        p.visibility, p.created_at, p.updated_at,
                        u.username, u.image_url
                FROM 
                        post p
                JOIN 
                        "user" u ON p.user_id = u.id
                WHERE 
                        p.id = $1
        `

        var post model.Post
        var embedURLsJSON, hashtagsJSON []byte
        var updatedAt sql.NullTime
        var visibilityStr string
        var username string
        var imageURL sql.NullString

        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;post.ID,
                &amp;post.UserID,
                &amp;post.Content,
                &amp;embedURLsJSON,
                &amp;hashtagsJSON,
                &amp;visibilityStr,
                &amp;post.CreatedAt,
                &amp;updatedAt,
                &amp;username,
                &amp;imageURL,
        )

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, apperrors.NotFound(fmt.Sprintf("post: %s", id))
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("query post: %w", err)</span>
        }

        // Parse JSON arrays
        <span class="cov0" title="0">if len(embedURLsJSON) &gt; 0 </span><span class="cov0" title="0">{
                if err := json.Unmarshal(embedURLsJSON, &amp;post.EmbedURLs); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unmarshal embed URLs: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if len(hashtagsJSON) &gt; 0 </span><span class="cov0" title="0">{
                if err := json.Unmarshal(hashtagsJSON, &amp;post.Hashtags); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unmarshal hashtags: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if updatedAt.Valid </span><span class="cov0" title="0">{
                post.UpdatedAt = &amp;updatedAt.Time
        }</span>

        <span class="cov0" title="0">post.Visibility = model.Visibility(visibilityStr)

        // Set up basic author information
        author := &amp;model.User{
                ID:       post.UserID,
                Username: username,
        }

        if imageURL.Valid </span><span class="cov0" title="0">{
                author.ImageURL = &amp;imageURL.String
        }</span>

        <span class="cov0" title="0">post.Author = author

        return &amp;post, nil</span>
}

// Update updates a post
func (r *postRepository) Update(ctx context.Context, post *model.Post) error <span class="cov0" title="0">{
        query := `
                UPDATE post
                SET 
                        content = $1, 
                        embed_urls = $2, 
                        hashtags = $3, 
                        updated_at = $4
                WHERE 
                        id = $5
                RETURNING id
        `

        now := time.Now().UTC()
        postUpdate := now
        post.UpdatedAt = &amp;postUpdate

        // Convert arrays to JSON
        embedURLsJSON, err := json.Marshal(post.EmbedURLs)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal embed URLs: %w", err)
        }</span>

        <span class="cov0" title="0">hashtagsJSON, err := json.Marshal(post.Hashtags)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal hashtags: %w", err)
        }</span>

        <span class="cov0" title="0">var id string
        err = r.db.QueryRowContext(ctx, query,
                post.Content,
                embedURLsJSON,
                hashtagsJSON,
                now,
                post.ID,
        ).Scan(&amp;id)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return apperrors.NotFound(fmt.Sprintf("post: %s", post.ID))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("update post: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Delete removes a post
func (r *postRepository) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        query := `DELETE FROM post WHERE id = $1 RETURNING id`

        var deletedID string
        err := r.db.QueryRowContext(ctx, query, id).Scan(&amp;deletedID)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return apperrors.NotFound(fmt.Sprintf("post: %s", id))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("delete post: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetByUserID fetches posts by user ID
func (r *postRepository) GetByUserID(ctx context.Context, userID string, limit, offset int) ([]*model.Post, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10 // Default limit
        }</span>

        <span class="cov0" title="0">query := `
                SELECT 
                        p.id, p.user_id, p.content, p.embed_urls, p.hashtags, 
                        p.visibility, p.created_at, p.updated_at,
                        u.username, u.image_url
                FROM 
                        post p
                JOIN 
                        "user" u ON p.user_id = u.id
                WHERE 
                        p.user_id = $1
                ORDER BY 
                        p.created_at DESC
                LIMIT $2 OFFSET $3
        `

        rows, err := r.db.QueryContext(ctx, query, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query user posts: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var posts []*model.Post

        for rows.Next() </span><span class="cov0" title="0">{
                var post model.Post
                var embedURLsJSON, hashtagsJSON []byte
                var updatedAt sql.NullTime
                var visibilityStr string
                var username string
                var imageURL sql.NullString

                err := rows.Scan(
                        &amp;post.ID,
                        &amp;post.UserID,
                        &amp;post.Content,
                        &amp;embedURLsJSON,
                        &amp;hashtagsJSON,
                        &amp;visibilityStr,
                        &amp;post.CreatedAt,
                        &amp;updatedAt,
                        &amp;username,
                        &amp;imageURL,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan post row: %w", err)
                }</span>

                // Parse JSON arrays
                <span class="cov0" title="0">if len(embedURLsJSON) &gt; 0 </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(embedURLsJSON, &amp;post.EmbedURLs); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unmarshal embed URLs: %w", err)
                        }</span>
                }

                <span class="cov0" title="0">if len(hashtagsJSON) &gt; 0 </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(hashtagsJSON, &amp;post.Hashtags); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unmarshal hashtags: %w", err)
                        }</span>
                }

                <span class="cov0" title="0">if updatedAt.Valid </span><span class="cov0" title="0">{
                        post.UpdatedAt = &amp;updatedAt.Time
                }</span>

                <span class="cov0" title="0">post.Visibility = model.Visibility(visibilityStr)

                // Set up basic author information
                author := &amp;model.User{
                        ID:       post.UserID,
                        Username: username,
                }

                if imageURL.Valid </span><span class="cov0" title="0">{
                        author.ImageURL = &amp;imageURL.String
                }</span>

                <span class="cov0" title="0">post.Author = author

                posts = append(posts, &amp;post)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rows iteration: %w", err)
        }</span>

        <span class="cov0" title="0">return posts, nil</span>
}

// GetFeed fetches posts for a feed
func (r *postRepository) GetFeed(ctx context.Context, userIDs []string, limit, offset int) ([]*model.Post, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10 // Default limit
        }</span>

        // If no userIDs provided, return empty slice
        <span class="cov0" title="0">if len(userIDs) == 0 </span><span class="cov0" title="0">{
                return []*model.Post{}, nil
        }</span>

        <span class="cov0" title="0">query := `
                SELECT 
                        p.id, p.user_id, p.content, p.embed_urls, p.hashtags, 
                        p.visibility, p.created_at, p.updated_at,
                        u.username, u.image_url
                FROM 
                        post p
                JOIN 
                        "user" u ON p.user_id = u.id
                WHERE 
                        p.user_id = ANY($1) AND
                        p.visibility = 'public'
                ORDER BY 
                        p.created_at DESC
                LIMIT $2 OFFSET $3
        `

        rows, err := r.db.QueryContext(ctx, query, userIDs, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query feed posts: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var posts []*model.Post

        for rows.Next() </span><span class="cov0" title="0">{
                var post model.Post
                var embedURLsJSON, hashtagsJSON []byte
                var updatedAt sql.NullTime
                var visibilityStr string
                var username string
                var imageURL sql.NullString

                err := rows.Scan(
                        &amp;post.ID,
                        &amp;post.UserID,
                        &amp;post.Content,
                        &amp;embedURLsJSON,
                        &amp;hashtagsJSON,
                        &amp;visibilityStr,
                        &amp;post.CreatedAt,
                        &amp;updatedAt,
                        &amp;username,
                        &amp;imageURL,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan feed post row: %w", err)
                }</span>

                // Parse JSON arrays
                <span class="cov0" title="0">if len(embedURLsJSON) &gt; 0 </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(embedURLsJSON, &amp;post.EmbedURLs); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unmarshal embed URLs: %w", err)
                        }</span>
                }

                <span class="cov0" title="0">if len(hashtagsJSON) &gt; 0 </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(hashtagsJSON, &amp;post.Hashtags); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unmarshal hashtags: %w", err)
                        }</span>
                }

                <span class="cov0" title="0">if updatedAt.Valid </span><span class="cov0" title="0">{
                        post.UpdatedAt = &amp;updatedAt.Time
                }</span>

                <span class="cov0" title="0">post.Visibility = model.Visibility(visibilityStr)

                // Set up basic author information
                author := &amp;model.User{
                        ID:       post.UserID,
                        Username: username,
                }

                if imageURL.Valid </span><span class="cov0" title="0">{
                        author.ImageURL = &amp;imageURL.String
                }</span>

                <span class="cov0" title="0">post.Author = author

                posts = append(posts, &amp;post)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rows iteration: %w", err)
        }</span>

        <span class="cov0" title="0">return posts, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package repository

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "time"

        "github.com/PeterM45/perfolio-api/internal/common/model"
        "github.com/PeterM45/perfolio-api/internal/platform/database"
        "github.com/PeterM45/perfolio-api/pkg/apperrors"
)

// UserRepository defines methods to interact with user data
type UserRepository interface {
        // User operations
        GetByID(ctx context.Context, id string) (*model.User, error)
        GetByEmail(ctx context.Context, email string) (*model.User, error)
        GetByUsername(ctx context.Context, username string) (*model.User, error)
        Create(ctx context.Context, user *model.User) error
        Update(ctx context.Context, id string, updates map[string]interface{}) error
        Search(ctx context.Context, query string, limit int) ([]*model.User, error)

        // Follow operations
        AddFollow(ctx context.Context, followerID, followingID string) error
        RemoveFollow(ctx context.Context, followerID, followingID string) error
        IsFollowing(ctx context.Context, followerID, followingID string) (bool, error)
        GetFollowerCount(ctx context.Context, userID string) (int, error)
        GetFollowingCount(ctx context.Context, userID string) (int, error)
        GetFollowers(ctx context.Context, userID string, limit, offset int) ([]*model.User, error)
        GetFollowing(ctx context.Context, userID string, limit, offset int) ([]*model.User, error)
}

type userRepository struct {
        db *database.DB
}

// NewUserRepository creates a new UserRepository
func NewUserRepository(db *database.DB) UserRepository <span class="cov0" title="0">{
        return &amp;userRepository{
                db: db,
        }
}</span>

// GetByID fetches a user by ID
func (r *userRepository) GetByID(ctx context.Context, id string) (*model.User, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        id, email, username, first_name, last_name, bio, 
                        auth_provider, image_url, is_active, created_at, updated_at
                FROM 
                        "user"
                WHERE 
                        id = $1
        `

        var user model.User
        var firstName, lastName, bio, imageURL sql.NullString
        var updatedAt sql.NullTime
        var authProviderStr string

        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;user.ID,
                &amp;user.Email,
                &amp;user.Username,
                &amp;firstName,
                &amp;lastName,
                &amp;bio,
                &amp;authProviderStr,
                &amp;imageURL,
                &amp;user.IsActive,
                &amp;user.CreatedAt,
                &amp;updatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, apperrors.NotFound(fmt.Sprintf("user: %s", id))
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("query user: %w", err)</span>
        }

        // Handle null fields
        <span class="cov0" title="0">if firstName.Valid </span><span class="cov0" title="0">{
                user.FirstName = &amp;firstName.String
        }</span>
        <span class="cov0" title="0">if lastName.Valid </span><span class="cov0" title="0">{
                user.LastName = &amp;lastName.String
        }</span>
        <span class="cov0" title="0">if bio.Valid </span><span class="cov0" title="0">{
                user.Bio = &amp;bio.String
        }</span>
        <span class="cov0" title="0">if imageURL.Valid </span><span class="cov0" title="0">{
                user.ImageURL = &amp;imageURL.String
        }</span>
        <span class="cov0" title="0">if updatedAt.Valid </span><span class="cov0" title="0">{
                user.UpdatedAt = &amp;updatedAt.Time
        }</span>

        <span class="cov0" title="0">user.AuthProvider = model.AuthProvider(authProviderStr)

        return &amp;user, nil</span>
}

// GetByUsername fetches a user by username
func (r *userRepository) GetByUsername(ctx context.Context, username string) (*model.User, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        id, email, username, first_name, last_name, bio, 
                        auth_provider, image_url, is_active, created_at, updated_at
                FROM 
                        "user"
                WHERE 
                        username = $1
        `

        var user model.User
        var firstName, lastName, bio, imageURL sql.NullString
        var updatedAt sql.NullTime
        var authProviderStr string

        err := r.db.QueryRowContext(ctx, query, username).Scan(
                &amp;user.ID,
                &amp;user.Email,
                &amp;user.Username,
                &amp;firstName,
                &amp;lastName,
                &amp;bio,
                &amp;authProviderStr,
                &amp;imageURL,
                &amp;user.IsActive,
                &amp;user.CreatedAt,
                &amp;updatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, apperrors.NotFound(fmt.Sprintf("user by username: %s", username))
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("query user by username: %w", err)</span>
        }

        // Handle null fields
        <span class="cov0" title="0">if firstName.Valid </span><span class="cov0" title="0">{
                user.FirstName = &amp;firstName.String
        }</span>
        <span class="cov0" title="0">if lastName.Valid </span><span class="cov0" title="0">{
                user.LastName = &amp;lastName.String
        }</span>
        <span class="cov0" title="0">if bio.Valid </span><span class="cov0" title="0">{
                user.Bio = &amp;bio.String
        }</span>
        <span class="cov0" title="0">if imageURL.Valid </span><span class="cov0" title="0">{
                user.ImageURL = &amp;imageURL.String
        }</span>
        <span class="cov0" title="0">if updatedAt.Valid </span><span class="cov0" title="0">{
                user.UpdatedAt = &amp;updatedAt.Time
        }</span>

        <span class="cov0" title="0">user.AuthProvider = model.AuthProvider(authProviderStr)

        return &amp;user, nil</span>
}

// GetByEmail fetches a user by email
func (r *userRepository) GetByEmail(ctx context.Context, email string) (*model.User, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        id, email, username, first_name, last_name, bio, 
                        auth_provider, image_url, is_active, created_at, updated_at
                FROM 
                        "user"
                WHERE 
                        email = $1
        `

        var user model.User
        var firstName, lastName, bio, imageURL sql.NullString
        var updatedAt sql.NullTime
        var authProviderStr string

        err := r.db.QueryRowContext(ctx, query, email).Scan(
                &amp;user.ID,
                &amp;user.Email,
                &amp;user.Username,
                &amp;firstName,
                &amp;lastName,
                &amp;bio,
                &amp;authProviderStr,
                &amp;imageURL,
                &amp;user.IsActive,
                &amp;user.CreatedAt,
                &amp;updatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, apperrors.NotFound(fmt.Sprintf("user by email: %s", email))
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("query user by email: %w", err)</span>
        }

        // Handle null fields
        <span class="cov0" title="0">if firstName.Valid </span><span class="cov0" title="0">{
                user.FirstName = &amp;firstName.String
        }</span>
        <span class="cov0" title="0">if lastName.Valid </span><span class="cov0" title="0">{
                user.LastName = &amp;lastName.String
        }</span>
        <span class="cov0" title="0">if bio.Valid </span><span class="cov0" title="0">{
                user.Bio = &amp;bio.String
        }</span>
        <span class="cov0" title="0">if imageURL.Valid </span><span class="cov0" title="0">{
                user.ImageURL = &amp;imageURL.String
        }</span>
        <span class="cov0" title="0">if updatedAt.Valid </span><span class="cov0" title="0">{
                user.UpdatedAt = &amp;updatedAt.Time
        }</span>

        <span class="cov0" title="0">user.AuthProvider = model.AuthProvider(authProviderStr)

        return &amp;user, nil</span>
}

// Create adds a new user
func (r *userRepository) Create(ctx context.Context, user *model.User) error <span class="cov0" title="0">{
        query := `
                INSERT INTO "user" (
                        id, email, username, first_name, last_name, bio,
                        auth_provider, image_url, is_active, created_at
                ) VALUES (
                        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
                )
        `

        now := time.Now().UTC()

        // Handle null fields
        var email, firstName, lastName, bio, imageURL sql.NullString

        if user.Email != "" </span><span class="cov0" title="0">{
                email = sql.NullString{String: user.Email, Valid: true}
        }</span>
        <span class="cov0" title="0">if user.FirstName != nil </span><span class="cov0" title="0">{
                firstName = sql.NullString{String: *user.FirstName, Valid: true}
        }</span>
        <span class="cov0" title="0">if user.LastName != nil </span><span class="cov0" title="0">{
                lastName = sql.NullString{String: *user.LastName, Valid: true}
        }</span>
        <span class="cov0" title="0">if user.Bio != nil </span><span class="cov0" title="0">{
                bio = sql.NullString{String: *user.Bio, Valid: true}
        }</span>
        <span class="cov0" title="0">if user.ImageURL != nil </span><span class="cov0" title="0">{
                imageURL = sql.NullString{String: *user.ImageURL, Valid: true}
        }</span>

        <span class="cov0" title="0">_, err := r.db.ExecContext(ctx, query,
                user.ID,
                email,
                user.Username,
                firstName,
                lastName,
                bio,
                string(user.AuthProvider),
                imageURL,
                user.IsActive,
                now,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create user: %w", err)
        }</span>

        <span class="cov0" title="0">user.CreatedAt = now

        return nil</span>
}

// Update updates user properties
func (r *userRepository) Update(ctx context.Context, id string, updates map[string]interface{}) error <span class="cov0" title="0">{
        // Start building query
        query := `UPDATE "user" SET updated_at = NOW()`
        params := []interface{}{id} // First param is ID for the WHERE clause
        paramCount := 1

        // Add each field to update
        for key, value := range updates </span><span class="cov0" title="0">{
                var dbField string

                // Map to database column names
                switch key </span>{
                case "username":<span class="cov0" title="0">
                        dbField = "username"</span>
                case "firstName":<span class="cov0" title="0">
                        dbField = "first_name"</span>
                case "lastName":<span class="cov0" title="0">
                        dbField = "last_name"</span>
                case "bio":<span class="cov0" title="0">
                        dbField = "bio"</span>
                case "imageUrl":<span class="cov0" title="0">
                        dbField = "image_url"</span>
                case "isActive":<span class="cov0" title="0">
                        dbField = "is_active"</span>
                default:<span class="cov0" title="0">
                        continue</span> // Skip unknown fields
                }

                <span class="cov0" title="0">paramCount++
                query += fmt.Sprintf(", %s = $%d", dbField, paramCount)
                params = append(params, value)</span>
        }

        <span class="cov0" title="0">query += fmt.Sprintf(" WHERE id = $1 RETURNING id")

        row := r.db.QueryRowContext(ctx, query, params...)
        var returnedID string
        if err := row.Scan(&amp;returnedID); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return apperrors.NotFound(fmt.Sprintf("user: %s", id))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("update user: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Search searches users by query
func (r *userRepository) Search(ctx context.Context, query string, limit int) ([]*model.User, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10 // Default limit
        }</span>

        <span class="cov0" title="0">sqlQuery := `
                SELECT 
                        id, email, username, first_name, last_name, bio, 
                        auth_provider, image_url, is_active, created_at, updated_at
                FROM 
                        "user"
                WHERE 
                        username ILIKE $1 OR
                        first_name ILIKE $1 OR
                        last_name ILIKE $1
                LIMIT $2
        `

        searchPattern := "%" + query + "%"
        rows, err := r.db.QueryContext(ctx, sqlQuery, searchPattern, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("search users: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var users []*model.User

        for rows.Next() </span><span class="cov0" title="0">{
                var user model.User
                var firstName, lastName, bio, imageURL, email sql.NullString
                var updatedAt sql.NullTime
                var authProviderStr string

                err := rows.Scan(
                        &amp;user.ID,
                        &amp;email,
                        &amp;user.Username,
                        &amp;firstName,
                        &amp;lastName,
                        &amp;bio,
                        &amp;authProviderStr,
                        &amp;imageURL,
                        &amp;user.IsActive,
                        &amp;user.CreatedAt,
                        &amp;updatedAt,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan user row: %w", err)
                }</span>

                // Handle null fields
                <span class="cov0" title="0">if email.Valid </span><span class="cov0" title="0">{
                        user.Email = email.String
                }</span>
                <span class="cov0" title="0">if firstName.Valid </span><span class="cov0" title="0">{
                        user.FirstName = &amp;firstName.String
                }</span>
                <span class="cov0" title="0">if lastName.Valid </span><span class="cov0" title="0">{
                        user.LastName = &amp;lastName.String
                }</span>
                <span class="cov0" title="0">if bio.Valid </span><span class="cov0" title="0">{
                        user.Bio = &amp;bio.String
                }</span>
                <span class="cov0" title="0">if imageURL.Valid </span><span class="cov0" title="0">{
                        user.ImageURL = &amp;imageURL.String
                }</span>
                <span class="cov0" title="0">if updatedAt.Valid </span><span class="cov0" title="0">{
                        user.UpdatedAt = &amp;updatedAt.Time
                }</span>

                <span class="cov0" title="0">user.AuthProvider = model.AuthProvider(authProviderStr)

                users = append(users, &amp;user)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rows iteration: %w", err)
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}

// AddFollow creates a follow relationship
func (r *userRepository) AddFollow(ctx context.Context, followerID, followingID string) error <span class="cov0" title="0">{
        // Check if users exist first
        for _, id := range []string{followerID, followingID} </span><span class="cov0" title="0">{
                exists, err := r.userExists(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        return apperrors.NotFound(fmt.Sprintf("user: %s", id))
                }</span>
        }

        // Check if already following
        <span class="cov0" title="0">isFollowing, err := r.IsFollowing(ctx, followerID, followingID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if isFollowing </span><span class="cov0" title="0">{
                return nil // Already following, just return success
        }</span>

        // Add follow
        <span class="cov0" title="0">query := `INSERT INTO follows (follower_id, following_id, created_at) VALUES ($1, $2, $3)`
        _, err = r.db.ExecContext(ctx, query, followerID, followingID, time.Now().UTC())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add follow: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RemoveFollow removes a follow relationship
func (r *userRepository) RemoveFollow(ctx context.Context, followerID, followingID string) error <span class="cov0" title="0">{
        query := `DELETE FROM follows WHERE follower_id = $1 AND following_id = $2`
        _, err := r.db.ExecContext(ctx, query, followerID, followingID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("remove follow: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// IsFollowing checks if a user is following another
func (r *userRepository) IsFollowing(ctx context.Context, followerID, followingID string) (bool, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM follows WHERE follower_id = $1 AND following_id = $2`

        var count int
        err := r.db.QueryRowContext(ctx, query, followerID, followingID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("check following: %w", err)
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// GetFollowerCount returns the number of followers for a user
func (r *userRepository) GetFollowerCount(ctx context.Context, userID string) (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM follows WHERE following_id = $1`

        var count int
        err := r.db.QueryRowContext(ctx, query, userID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("get follower count: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// GetFollowingCount returns the number of users a user is following
func (r *userRepository) GetFollowingCount(ctx context.Context, userID string) (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM follows WHERE follower_id = $1`

        var count int
        err := r.db.QueryRowContext(ctx, query, userID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("get following count: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// GetFollowers returns a list of users following the given user
func (r *userRepository) GetFollowers(ctx context.Context, userID string, limit, offset int) ([]*model.User, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10 // Default limit
        }</span>

        <span class="cov0" title="0">query := `
                SELECT 
                        u.id, u.email, u.username, u.first_name, u.last_name, u.bio, 
                        u.auth_provider, u.image_url, u.is_active, u.created_at, u.updated_at
                FROM 
                        "user" u
                JOIN 
                        follows f ON u.id = f.follower_id
                WHERE 
                        f.following_id = $1
                LIMIT $2 OFFSET $3
        `

        rows, err := r.db.QueryContext(ctx, query, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get followers: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var users []*model.User

        for rows.Next() </span><span class="cov0" title="0">{
                var user model.User
                var firstName, lastName, bio, imageURL, email sql.NullString
                var updatedAt sql.NullTime
                var authProviderStr string

                err := rows.Scan(
                        &amp;user.ID,
                        &amp;email,
                        &amp;user.Username,
                        &amp;firstName,
                        &amp;lastName,
                        &amp;bio,
                        &amp;authProviderStr,
                        &amp;imageURL,
                        &amp;user.IsActive,
                        &amp;user.CreatedAt,
                        &amp;updatedAt,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan follower row: %w", err)
                }</span>

                // Handle null fields
                <span class="cov0" title="0">if email.Valid </span><span class="cov0" title="0">{
                        user.Email = email.String
                }</span>
                <span class="cov0" title="0">if firstName.Valid </span><span class="cov0" title="0">{
                        user.FirstName = &amp;firstName.String
                }</span>
                <span class="cov0" title="0">if lastName.Valid </span><span class="cov0" title="0">{
                        user.LastName = &amp;lastName.String
                }</span>
                <span class="cov0" title="0">if bio.Valid </span><span class="cov0" title="0">{
                        user.Bio = &amp;bio.String
                }</span>
                <span class="cov0" title="0">if imageURL.Valid </span><span class="cov0" title="0">{
                        user.ImageURL = &amp;imageURL.String
                }</span>
                <span class="cov0" title="0">if updatedAt.Valid </span><span class="cov0" title="0">{
                        user.UpdatedAt = &amp;updatedAt.Time
                }</span>

                <span class="cov0" title="0">user.AuthProvider = model.AuthProvider(authProviderStr)

                users = append(users, &amp;user)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rows iteration: %w", err)
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}

// GetFollowing returns a list of users the given user is following
func (r *userRepository) GetFollowing(ctx context.Context, userID string, limit, offset int) ([]*model.User, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10 // Default limit
        }</span>

        <span class="cov0" title="0">query := `
                SELECT 
                        u.id, u.email, u.username, u.first_name, u.last_name, u.bio, 
                        u.auth_provider, u.image_url, u.is_active, u.created_at, u.updated_at
                FROM 
                        "user" u
                JOIN 
                        follows f ON u.id = f.following_id
                WHERE 
                        f.follower_id = $1
                LIMIT $2 OFFSET $3
        `

        rows, err := r.db.QueryContext(ctx, query, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get following: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var users []*model.User

        for rows.Next() </span><span class="cov0" title="0">{
                var user model.User
                var firstName, lastName, bio, imageURL, email sql.NullString
                var updatedAt sql.NullTime
                var authProviderStr string

                err := rows.Scan(
                        &amp;user.ID,
                        &amp;email,
                        &amp;user.Username,
                        &amp;firstName,
                        &amp;lastName,
                        &amp;bio,
                        &amp;authProviderStr,
                        &amp;imageURL,
                        &amp;user.IsActive,
                        &amp;user.CreatedAt,
                        &amp;updatedAt,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan following row: %w", err)
                }</span>

                // Handle null fields
                <span class="cov0" title="0">if email.Valid </span><span class="cov0" title="0">{
                        user.Email = email.String
                }</span>
                <span class="cov0" title="0">if firstName.Valid </span><span class="cov0" title="0">{
                        user.FirstName = &amp;firstName.String
                }</span>
                <span class="cov0" title="0">if lastName.Valid </span><span class="cov0" title="0">{
                        user.LastName = &amp;lastName.String
                }</span>
                <span class="cov0" title="0">if bio.Valid </span><span class="cov0" title="0">{
                        user.Bio = &amp;bio.String
                }</span>
                <span class="cov0" title="0">if imageURL.Valid </span><span class="cov0" title="0">{
                        user.ImageURL = &amp;imageURL.String
                }</span>
                <span class="cov0" title="0">if updatedAt.Valid </span><span class="cov0" title="0">{
                        user.UpdatedAt = &amp;updatedAt.Time
                }</span>

                <span class="cov0" title="0">user.AuthProvider = model.AuthProvider(authProviderStr)

                users = append(users, &amp;user)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rows iteration: %w", err)
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}

// Helper function to check if a user exists
func (r *userRepository) userExists(ctx context.Context, id string) (bool, error) <span class="cov0" title="0">{
        var exists bool
        query := `SELECT EXISTS(SELECT 1 FROM "user" WHERE id = $1)`
        err := r.db.QueryRowContext(ctx, query, id).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("check user exists: %w", err)
        }</span>
        <span class="cov0" title="0">return exists, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package repository

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/PeterM45/perfolio-api/internal/common/model"
        "github.com/PeterM45/perfolio-api/internal/platform/database"
        "github.com/PeterM45/perfolio-api/pkg/apperrors"
        "github.com/google/uuid"
)

// WidgetRepository defines methods to interact with widget data
type WidgetRepository interface {
        GetByID(ctx context.Context, id string) (*model.Widget, error)
        GetByUserID(ctx context.Context, userID string) ([]*model.Widget, error)
        Create(ctx context.Context, widget *model.Widget) error
        Update(ctx context.Context, widget *model.Widget) error
        Delete(ctx context.Context, id string) error
        BatchUpdatePositions(ctx context.Context, updates []*model.WidgetPositionUpdate) error
}

type widgetRepository struct {
        db *database.DB
}

// NewWidgetRepository creates a new WidgetRepository
func NewWidgetRepository(db *database.DB) WidgetRepository <span class="cov0" title="0">{
        return &amp;widgetRepository{
                db: db,
        }
}</span>

// GetByID fetches a widget by ID
func (r *widgetRepository) GetByID(ctx context.Context, id string) (*model.Widget, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        id, user_id, type, component, x, y, w, h, settings
                FROM 
                        widgets
                WHERE 
                        id = $1
        `

        var widget model.Widget
        var settings sql.NullString

        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;widget.ID,
                &amp;widget.UserID,
                &amp;widget.Type,
                &amp;widget.Component,
                &amp;widget.X,
                &amp;widget.Y,
                &amp;widget.W,
                &amp;widget.H,
                &amp;settings,
        )

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, apperrors.NotFound(fmt.Sprintf("widget with ID %s", id))
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("query widget: %w", err)</span>
        }

        <span class="cov0" title="0">if settings.Valid </span><span class="cov0" title="0">{
                widget.Settings = &amp;settings.String
        }</span>

        <span class="cov0" title="0">return &amp;widget, nil</span>
}

// GetByUserID fetches widgets for a user
func (r *widgetRepository) GetByUserID(ctx context.Context, userID string) ([]*model.Widget, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        id, user_id, type, component, x, y, w, h, settings
                FROM 
                        widgets
                WHERE 
                        user_id = $1
                ORDER BY
                        y ASC, x ASC
        `

        rows, err := r.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query user widgets: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var widgets []*model.Widget

        for rows.Next() </span><span class="cov0" title="0">{
                var widget model.Widget
                var settings sql.NullString

                err := rows.Scan(
                        &amp;widget.ID,
                        &amp;widget.UserID,
                        &amp;widget.Type,
                        &amp;widget.Component,
                        &amp;widget.X,
                        &amp;widget.Y,
                        &amp;widget.W,
                        &amp;widget.H,
                        &amp;settings,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan widget row: %w", err)
                }</span>

                <span class="cov0" title="0">if settings.Valid </span><span class="cov0" title="0">{
                        widget.Settings = &amp;settings.String
                }</span>

                <span class="cov0" title="0">widgets = append(widgets, &amp;widget)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rows iteration: %w", err)
        }</span>

        <span class="cov0" title="0">return widgets, nil</span>
}

// Create adds a new widget
func (r *widgetRepository) Create(ctx context.Context, widget *model.Widget) error <span class="cov0" title="0">{
        if widget.ID == "" </span><span class="cov0" title="0">{
                widget.ID = uuid.New().String()
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO widgets (
                        id, user_id, type, component, x, y, w, h, settings
                ) VALUES (
                        $1, $2, $3, $4, $5, $6, $7, $8, $9
                )
        `

        var settingsSQL sql.NullString
        if widget.Settings != nil </span><span class="cov0" title="0">{
                settingsSQL = sql.NullString{String: *widget.Settings, Valid: true}
        }</span>

        <span class="cov0" title="0">_, err := r.db.ExecContext(ctx, query,
                widget.ID,
                widget.UserID,
                widget.Type,
                widget.Component,
                widget.X,
                widget.Y,
                widget.W,
                widget.H,
                settingsSQL,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create widget: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Update updates a widget
func (r *widgetRepository) Update(ctx context.Context, widget *model.Widget) error <span class="cov0" title="0">{
        query := `
                UPDATE widgets
                SET 
                        type = $1, 
                        component = $2, 
                        x = $3, 
                        y = $4, 
                        w = $5, 
                        h = $6, 
                        settings = $7
                WHERE 
                        id = $8 AND user_id = $9
                RETURNING id
        `

        var settingsSQL sql.NullString
        if widget.Settings != nil </span><span class="cov0" title="0">{
                settingsSQL = sql.NullString{String: *widget.Settings, Valid: true}
        }</span>

        <span class="cov0" title="0">var id string
        err := r.db.QueryRowContext(ctx, query,
                widget.Type,
                widget.Component,
                widget.X,
                widget.Y,
                widget.W,
                widget.H,
                settingsSQL,
                widget.ID,
                widget.UserID,
        ).Scan(&amp;id)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return apperrors.NotFound(fmt.Sprintf("widget: %s", widget.ID))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("update widget: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Delete removes a widget
func (r *widgetRepository) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        query := `DELETE FROM widgets WHERE id = $1 RETURNING id`

        var deletedID string
        err := r.db.QueryRowContext(ctx, query, id).Scan(&amp;deletedID)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return apperrors.NotFound(fmt.Sprintf("widget: %s", id))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("delete widget: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// BatchUpdatePositions updates multiple widget positions in a transaction
func (r *widgetRepository) BatchUpdatePositions(ctx context.Context, updates []*model.WidgetPositionUpdate) error <span class="cov0" title="0">{
        // Begin transaction
        tx, err := r.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Prepare statement for repeated use
        stmt, err := tx.PrepareContext(ctx, `
                UPDATE widgets
                SET x = $1, y = $2, w = $3, h = $4
                WHERE id = $5 AND user_id = $6
                RETURNING id
        `)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("prepare statement: %w", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        // Execute updates
        for _, update := range updates </span><span class="cov0" title="0">{
                var id string
                err := stmt.QueryRowContext(ctx,
                        update.X,
                        update.Y,
                        update.W,
                        update.H,
                        update.ID,
                        update.UserID,
                ).Scan(&amp;id)

                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                                return apperrors.NotFound(fmt.Sprintf("widget: %s", update.ID))
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("update widget position: %w", err)</span>
                }
        }

        // Commit transaction
        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package service

import (
        "context"
        "fmt"
        "time"

        "github.com/PeterM45/perfolio-api/internal/common/interfaces"
        "github.com/PeterM45/perfolio-api/internal/common/model"
        "github.com/PeterM45/perfolio-api/internal/platform/cache"
        "github.com/PeterM45/perfolio-api/internal/user/repository"
        "github.com/PeterM45/perfolio-api/pkg/apperrors"
        "github.com/PeterM45/perfolio-api/pkg/logger"
        "github.com/PeterM45/perfolio-api/pkg/validator"
        "github.com/google/uuid"
)

// PostService defines methods for post business logic
type PostService interface {
        CreatePost(ctx context.Context, userID string, req *model.CreatePostRequest) (*model.Post, error)
        GetPostByID(ctx context.Context, id string) (*model.Post, error)
        UpdatePost(ctx context.Context, id string, userID string, req *model.UpdatePostRequest) (*model.Post, error)
        DeletePost(ctx context.Context, id string, userID string) error
        GetUserPosts(ctx context.Context, userID string, limit, offset int) ([]*model.Post, error)
        GetFeed(ctx context.Context, userID string, limit, offset int) ([]*model.Post, error)
}

type postService struct {
        repo        repository.PostRepository
        userService interfaces.UserService
        cache       cache.Cache
        validator   validator.Validator
        logger      logger.Logger
}

// NewPostService creates a new PostService
func NewPostService(
        repo repository.PostRepository,
        userService interfaces.UserService,
        cache cache.Cache,
        logger logger.Logger,
) PostService <span class="cov0" title="0">{
        return &amp;postService{
                repo:        repo,
                userService: userService,
                cache:       cache,
                validator:   validator.NewValidator(),
                logger:      logger,
        }
}</span>

// CreatePost creates a new post
func (s *postService) CreatePost(ctx context.Context, userID string, req *model.CreatePostRequest) (*model.Post, error) <span class="cov0" title="0">{
        if err := s.validator.Validate(req); err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.BadRequest(err.Error())
        }</span>

        // Verify user exists
        <span class="cov0" title="0">if _, err := s.userService.GetUserByID(ctx, userID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create post
        <span class="cov0" title="0">post := &amp;model.Post{
                ID:         uuid.New().String(),
                UserID:     userID,
                Content:    req.Content,
                EmbedURLs:  req.EmbedURLs,
                Hashtags:   req.Hashtags,
                Visibility: model.VisibilityPublic, // Default visibility
        }

        if err := s.repo.Create(ctx, post); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Invalidate feed caches
        <span class="cov0" title="0">s.cache.Delete(fmt.Sprintf("user_posts:%s", userID))

        return post, nil</span>
}

// GetPostByID retrieves a post by ID
func (s *postService) GetPostByID(ctx context.Context, id string) (*model.Post, error) <span class="cov0" title="0">{
        if id == "" </span><span class="cov0" title="0">{
                return nil, apperrors.BadRequest("post ID cannot be empty")
        }</span>

        // Check cache first
        <span class="cov0" title="0">cacheKey := fmt.Sprintf("post:%s", id)
        if cachedPost, found := s.cache.Get(cacheKey); found </span><span class="cov0" title="0">{
                s.logger.Debug().Str("post_id", id).Msg("Post found in cache")
                return cachedPost.(*model.Post), nil
        }</span>

        <span class="cov0" title="0">post, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store in cache
        <span class="cov0" title="0">s.cache.Set(cacheKey, post, 5*time.Minute)

        return post, nil</span>
}

// UpdatePost updates an existing post
func (s *postService) UpdatePost(ctx context.Context, id string, userID string, req *model.UpdatePostRequest) (*model.Post, error) <span class="cov0" title="0">{
        if id == "" </span><span class="cov0" title="0">{
                return nil, apperrors.BadRequest("post ID cannot be empty")
        }</span>

        <span class="cov0" title="0">if err := s.validator.Validate(req); err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.BadRequest(err.Error())
        }</span>

        // Get existing post
        <span class="cov0" title="0">post, err := s.GetPostByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if user owns the post
        <span class="cov0" title="0">if post.UserID != userID </span><span class="cov0" title="0">{
                return nil, apperrors.Forbidden("you don't have permission to update this post")
        }</span>

        // Update post fields
        <span class="cov0" title="0">post.Content = req.Content
        post.EmbedURLs = req.EmbedURLs
        post.Hashtags = req.Hashtags

        // Save updates
        if err := s.repo.Update(ctx, post); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Invalidate cache
        <span class="cov0" title="0">s.cache.Delete(fmt.Sprintf("post:%s", id))
        s.cache.Delete(fmt.Sprintf("user_posts:%s", userID))

        return post, nil</span>
}

// DeletePost deletes a post
func (s *postService) DeletePost(ctx context.Context, id string, userID string) error <span class="cov0" title="0">{
        if id == "" </span><span class="cov0" title="0">{
                return apperrors.BadRequest("post ID cannot be empty")
        }</span>

        // Get existing post
        <span class="cov0" title="0">post, err := s.GetPostByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if user owns the post
        <span class="cov0" title="0">if post.UserID != userID </span><span class="cov0" title="0">{
                return apperrors.Forbidden("you don't have permission to delete this post")
        }</span>

        // Delete post
        <span class="cov0" title="0">if err := s.repo.Delete(ctx, id); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Invalidate cache
        <span class="cov0" title="0">s.cache.Delete(fmt.Sprintf("post:%s", id))
        s.cache.Delete(fmt.Sprintf("user_posts:%s", userID))

        return nil</span>
}

// GetUserPosts gets posts by a user
func (s *postService) GetUserPosts(ctx context.Context, userID string, limit, offset int) ([]*model.Post, error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return nil, apperrors.BadRequest("user ID cannot be empty")
        }</span>

        // Verify user exists
        <span class="cov0" title="0">if _, err := s.userService.GetUserByID(ctx, userID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check cache for list of posts
        <span class="cov0" title="0">cacheKey := fmt.Sprintf("user_posts:%s:%d:%d", userID, limit, offset)
        if cachedPosts, found := s.cache.Get(cacheKey); found </span><span class="cov0" title="0">{
                s.logger.Debug().Str("user_id", userID).Msg("User posts found in cache")
                return cachedPosts.([]*model.Post), nil
        }</span>

        <span class="cov0" title="0">posts, err := s.repo.GetByUserID(ctx, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store in cache
        <span class="cov0" title="0">s.cache.Set(cacheKey, posts, 2*time.Minute) // Shorter TTL for lists

        return posts, nil</span>
}

// GetFeed gets posts for user's feed
func (s *postService) GetFeed(ctx context.Context, userID string, limit, offset int) ([]*model.Post, error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return nil, apperrors.BadRequest("user ID cannot be empty")
        }</span>

        // Verify user exists
        <span class="cov0" title="0">if _, err := s.userService.GetUserByID(ctx, userID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get following users
        <span class="cov0" title="0">following, err := s.userService.GetFollowing(ctx, userID, 500, 0) // Get a reasonable number of followed users
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Build array of user IDs to fetch posts from (include self)
        <span class="cov0" title="0">userIDs := []string{userID}
        for _, user := range following </span><span class="cov0" title="0">{
                userIDs = append(userIDs, user.ID)
        }</span>

        // Check cache
        <span class="cov0" title="0">cacheKey := fmt.Sprintf("feed:%s:%d:%d", userID, limit, offset)
        if cachedFeed, found := s.cache.Get(cacheKey); found </span><span class="cov0" title="0">{
                s.logger.Debug().Str("user_id", userID).Msg("Feed found in cache")
                return cachedFeed.([]*model.Post), nil
        }</span>

        // Get posts
        <span class="cov0" title="0">posts, err := s.repo.GetFeed(ctx, userIDs, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store in cache (short TTL for feeds)
        <span class="cov0" title="0">s.cache.Set(cacheKey, posts, 1*time.Minute)

        return posts, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package service

import (
        "context"
        "fmt"
        "time"

        "github.com/PeterM45/perfolio-api/internal/common/interfaces"
        "github.com/PeterM45/perfolio-api/internal/common/model"
        "github.com/PeterM45/perfolio-api/internal/platform/cache"
        "github.com/PeterM45/perfolio-api/internal/user/repository"
        "github.com/PeterM45/perfolio-api/pkg/apperrors"
        "github.com/PeterM45/perfolio-api/pkg/logger"
        "github.com/PeterM45/perfolio-api/pkg/validator"
        "github.com/google/uuid"
)

// WidgetService defines methods for widget business logic
type WidgetService interface {
        GetWidgetByID(ctx context.Context, id string) (*model.Widget, error)
        GetUserWidgets(ctx context.Context, userID string) ([]*model.Widget, error)
        CreateWidget(ctx context.Context, userID string, req *model.CreateWidgetRequest) (*model.Widget, error)
        UpdateWidget(ctx context.Context, id string, userID string, req *model.UpdateWidgetRequest) (*model.Widget, error)
        DeleteWidget(ctx context.Context, id string, userID string) error
        BatchUpdateWidgets(ctx context.Context, userID string, req *model.BatchUpdateWidgetsRequest) error
}

type widgetService struct {
        repo        repository.WidgetRepository
        userService interfaces.UserService
        cache       cache.Cache
        validator   validator.Validator
        logger      logger.Logger
}

// NewWidgetService creates a new WidgetService
func NewWidgetService(
        repo repository.WidgetRepository,
        userService interfaces.UserService,
        cache cache.Cache,
        logger logger.Logger,
) WidgetService <span class="cov0" title="0">{
        return &amp;widgetService{
                repo:        repo,
                userService: userService,
                cache:       cache,
                validator:   validator.NewValidator(),
                logger:      logger,
        }
}</span>

// GetWidgetByID retrieves a widget by ID
func (s *widgetService) GetWidgetByID(ctx context.Context, id string) (*model.Widget, error) <span class="cov0" title="0">{
        if id == "" </span><span class="cov0" title="0">{
                return nil, apperrors.BadRequest("widget ID cannot be empty")
        }</span>

        // Check cache first
        <span class="cov0" title="0">cacheKey := fmt.Sprintf("widget:%s", id)
        if cachedWidget, found := s.cache.Get(cacheKey); found </span><span class="cov0" title="0">{
                s.logger.Debug().Str("widget_id", id).Msg("Widget found in cache")
                return cachedWidget.(*model.Widget), nil
        }</span>

        <span class="cov0" title="0">widget, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store in cache
        <span class="cov0" title="0">s.cache.Set(cacheKey, widget, 5*time.Minute)

        return widget, nil</span>
}

// GetUserWidgets gets all widgets for a user
func (s *widgetService) GetUserWidgets(ctx context.Context, userID string) ([]*model.Widget, error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return nil, apperrors.BadRequest("user ID cannot be empty")
        }</span>

        // Verify user exists
        <span class="cov0" title="0">if _, err := s.userService.GetUserByID(ctx, userID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check cache
        <span class="cov0" title="0">cacheKey := fmt.Sprintf("user_widgets:%s", userID)
        if cachedWidgets, found := s.cache.Get(cacheKey); found </span><span class="cov0" title="0">{
                s.logger.Debug().Str("user_id", userID).Msg("User widgets found in cache")
                return cachedWidgets.([]*model.Widget), nil
        }</span>

        <span class="cov0" title="0">widgets, err := s.repo.GetByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store in cache
        <span class="cov0" title="0">s.cache.Set(cacheKey, widgets, 5*time.Minute)

        return widgets, nil</span>
}

// CreateWidget creates a new widget
func (s *widgetService) CreateWidget(ctx context.Context, userID string, req *model.CreateWidgetRequest) (*model.Widget, error) <span class="cov0" title="0">{
        if err := s.validator.Validate(req); err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.BadRequest(err.Error())
        }</span>

        // Verify user exists
        <span class="cov0" title="0">if _, err := s.userService.GetUserByID(ctx, userID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create widget
        <span class="cov0" title="0">widget := &amp;model.Widget{
                ID:        uuid.New().String(),
                UserID:    userID,
                Type:      req.Type,
                Component: req.Component,
                X:         req.X,
                Y:         req.Y,
                W:         req.W,
                H:         req.H,
        }

        if req.Settings != "" </span><span class="cov0" title="0">{
                widget.Settings = &amp;req.Settings
        }</span>

        <span class="cov0" title="0">if err := s.repo.Create(ctx, widget); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Invalidate cache
        <span class="cov0" title="0">s.cache.Delete(fmt.Sprintf("user_widgets:%s", userID))

        return widget, nil</span>
}

// UpdateWidget updates an existing widget
func (s *widgetService) UpdateWidget(ctx context.Context, id string, userID string, req *model.UpdateWidgetRequest) (*model.Widget, error) <span class="cov0" title="0">{
        if id == "" </span><span class="cov0" title="0">{
                return nil, apperrors.BadRequest("widget ID cannot be empty")
        }</span>

        <span class="cov0" title="0">if err := s.validator.Validate(req); err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.BadRequest(err.Error())
        }</span>

        // Get existing widget
        <span class="cov0" title="0">widget, err := s.GetWidgetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if user owns the widget
        <span class="cov0" title="0">if widget.UserID != userID </span><span class="cov0" title="0">{
                return nil, apperrors.Forbidden("you don't have permission to update this widget")
        }</span>

        // Update widget fields
        <span class="cov0" title="0">if req.Type != nil </span><span class="cov0" title="0">{
                widget.Type = *req.Type
        }</span>

        <span class="cov0" title="0">if req.Component != nil </span><span class="cov0" title="0">{
                widget.Component = *req.Component
        }</span>

        <span class="cov0" title="0">if req.X != nil </span><span class="cov0" title="0">{
                widget.X = *req.X
        }</span>

        <span class="cov0" title="0">if req.Y != nil </span><span class="cov0" title="0">{
                widget.Y = *req.Y
        }</span>

        <span class="cov0" title="0">if req.W != nil </span><span class="cov0" title="0">{
                widget.W = *req.W
        }</span>

        <span class="cov0" title="0">if req.H != nil </span><span class="cov0" title="0">{
                widget.H = *req.H
        }</span>

        <span class="cov0" title="0">if req.Settings != nil </span><span class="cov0" title="0">{
                widget.Settings = req.Settings
        }</span>

        // Save updates
        <span class="cov0" title="0">if err := s.repo.Update(ctx, widget); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Invalidate cache
        <span class="cov0" title="0">s.cache.Delete(fmt.Sprintf("widget:%s", id))
        s.cache.Delete(fmt.Sprintf("user_widgets:%s", userID))

        return widget, nil</span>
}

// DeleteWidget deletes a widget
func (s *widgetService) DeleteWidget(ctx context.Context, id string, userID string) error <span class="cov0" title="0">{
        if id == "" </span><span class="cov0" title="0">{
                return apperrors.BadRequest("widget ID cannot be empty")
        }</span>

        // Get existing widget
        <span class="cov0" title="0">widget, err := s.GetWidgetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if user owns the widget
        <span class="cov0" title="0">if widget.UserID != userID </span><span class="cov0" title="0">{
                return apperrors.Forbidden("you don't have permission to delete this widget")
        }</span>

        // Delete widget
        <span class="cov0" title="0">if err := s.repo.Delete(ctx, id); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Invalidate cache
        <span class="cov0" title="0">s.cache.Delete(fmt.Sprintf("widget:%s", id))
        s.cache.Delete(fmt.Sprintf("user_widgets:%s", userID))

        return nil</span>
}

// BatchUpdateWidgets updates multiple widget positions
func (s *widgetService) BatchUpdateWidgets(ctx context.Context, userID string, req *model.BatchUpdateWidgetsRequest) error <span class="cov0" title="0">{
        if err := s.validator.Validate(req); err != nil </span><span class="cov0" title="0">{
                return apperrors.BadRequest(err.Error())
        }</span>

        // Verify user exists
        <span class="cov0" title="0">if _, err := s.userService.GetUserByID(ctx, userID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Verify all widgets belong to user
        <span class="cov0" title="0">updates := make([]*model.WidgetPositionUpdate, 0, len(req.Updates))
        for _, update := range req.Updates </span><span class="cov0" title="0">{
                if update.UserID != userID </span><span class="cov0" title="0">{
                        return apperrors.Forbidden("you can only update your own widgets")
                }</span>
                <span class="cov0" title="0">updates = append(updates, &amp;update)</span>
        }

        // Perform batch update
        <span class="cov0" title="0">if err := s.repo.BatchUpdatePositions(ctx, updates); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Invalidate cache
        <span class="cov0" title="0">s.cache.Delete(fmt.Sprintf("user_widgets:%s", userID))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package apperrors

import (
        "fmt"
        "net/http"
)

// ErrorType represents the type of error
type ErrorType string

// Error types - using different names than the function constructors
const (
        ErrTypeBadRequest   ErrorType = "BAD_REQUEST"
        ErrTypeNotFound     ErrorType = "NOT_FOUND"
        ErrTypeUnauthorized ErrorType = "UNAUTHORIZED"
        ErrTypeForbidden    ErrorType = "FORBIDDEN"
        ErrTypeConflict     ErrorType = "CONFLICT"
        ErrTypeInternal     ErrorType = "INTERNAL"
)

// Error represents an application error
type Error struct {
        errorType ErrorType
        message   string
}

// Error returns the error message
func (e *Error) Error() string <span class="cov0" title="0">{
        return e.message
}</span>

// Type returns the error type
func (e *Error) Type() ErrorType <span class="cov0" title="0">{
        return e.errorType
}</span>

// Status returns the HTTP status code
func (e *Error) Status() int <span class="cov0" title="0">{
        switch e.errorType </span>{
        case ErrTypeBadRequest:<span class="cov0" title="0">
                return http.StatusBadRequest</span>
        case ErrTypeNotFound:<span class="cov0" title="0">
                return http.StatusNotFound</span>
        case ErrTypeUnauthorized:<span class="cov0" title="0">
                return http.StatusUnauthorized</span>
        case ErrTypeForbidden:<span class="cov0" title="0">
                return http.StatusForbidden</span>
        case ErrTypeConflict:<span class="cov0" title="0">
                return http.StatusConflict</span>
        default:<span class="cov0" title="0">
                return http.StatusInternalServerError</span>
        }
}

// Error factory functions
func BadRequest(message string) *Error <span class="cov0" title="0">{
        return &amp;Error{
                errorType: ErrTypeBadRequest,
                message:   message,
        }
}</span>

func NotFound(message string) *Error <span class="cov0" title="0">{
        return &amp;Error{
                errorType: ErrTypeNotFound,
                message:   message,
        }
}</span>

func Unauthorized(message string) *Error <span class="cov0" title="0">{
        return &amp;Error{
                errorType: ErrTypeUnauthorized,
                message:   message,
        }
}</span>

func Forbidden(message string) *Error <span class="cov0" title="0">{
        return &amp;Error{
                errorType: ErrTypeForbidden,
                message:   message,
        }
}</span>

func Conflict(message string) *Error <span class="cov0" title="0">{
        return &amp;Error{
                errorType: ErrTypeConflict,
                message:   message,
        }
}</span>

func InternalError(message string) *Error <span class="cov0" title="0">{
        return &amp;Error{
                errorType: ErrTypeInternal,
                message:   message,
        }
}</span>

// Wrap wraps an error with a new error type
func Wrap(err error, errorType ErrorType, message string) *Error <span class="cov0" title="0">{
        if message == "" </span><span class="cov0" title="0">{
                message = err.Error()
        }</span> else<span class="cov0" title="0"> {
                message = fmt.Sprintf("%s: %s", message, err.Error())
        }</span>
        <span class="cov0" title="0">return &amp;Error{
                errorType: errorType,
                message:   message,
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package logger

import (
        "os"
        "strings"

        "github.com/rs/zerolog"
)

// Logger is a wrapper around zerolog.Logger
type Logger interface {
        Debug() *zerolog.Event // Changed return type to pointer
        Info() *zerolog.Event  // Changed return type to pointer
        Warn() *zerolog.Event  // Changed return type to pointer
        Error() *zerolog.Event // Changed return type to pointer
        Fatal() *zerolog.Event // Changed return type to pointer
}

// zerologLogger is an implementation of Logger using zerolog
type zerologLogger struct {
        logger zerolog.Logger
}

// NewLogger creates a new logger instance
func NewLogger(level string) Logger <span class="cov0" title="0">{
        // Fixed the constant usage
        zerolog.TimeFieldFormat = zerolog.TimeFormatUnix // Changed to an existing constant

        // Set log level
        var logLevel zerolog.Level
        switch strings.ToLower(level) </span>{
        case "debug":<span class="cov0" title="0">
                logLevel = zerolog.DebugLevel</span>
        case "info":<span class="cov0" title="0">
                logLevel = zerolog.InfoLevel</span>
        case "warn":<span class="cov0" title="0">
                logLevel = zerolog.WarnLevel</span>
        case "error":<span class="cov0" title="0">
                logLevel = zerolog.ErrorLevel</span>
        default:<span class="cov0" title="0">
                logLevel = zerolog.InfoLevel</span>
        }

        <span class="cov0" title="0">return &amp;zerologLogger{
                logger: zerolog.New(os.Stdout).
                        Level(logLevel).
                        With().
                        Timestamp().
                        Logger(),
        }</span>
}

// Debug returns a debug event logger
func (l *zerologLogger) Debug() *zerolog.Event <span class="cov0" title="0">{
        return l.logger.Debug()
}</span>

// Info returns an info event logger
func (l *zerologLogger) Info() *zerolog.Event <span class="cov0" title="0">{
        return l.logger.Info()
}</span>

// Warn returns a warn event logger
func (l *zerologLogger) Warn() *zerolog.Event <span class="cov0" title="0">{
        return l.logger.Warn()
}</span>

// Error returns an error event logger
func (l *zerologLogger) Error() *zerolog.Event <span class="cov0" title="0">{
        return l.logger.Error()
}</span>

// Fatal returns a fatal event logger
func (l *zerologLogger) Fatal() *zerolog.Event <span class="cov0" title="0">{
        return l.logger.Fatal()
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package validator

import (
        "fmt"
        "reflect"
        "strings"

        "github.com/go-playground/validator/v10"
)

// Validator defines validation methods
type Validator interface {
        Validate(i interface{}) error
}

// CustomValidator implements Validator with validator.v10
type CustomValidator struct {
        validator *validator.Validate
}

// NewValidator creates a new validator
func NewValidator() Validator <span class="cov0" title="0">{
        v := validator.New()

        // Register a function to get the field name from the struct tags
        v.RegisterTagNameFunc(func(fld reflect.StructField) string </span><span class="cov0" title="0">{
                name := strings.SplitN(fld.Tag.Get("json"), ",", 2)[0]
                if name == "-" </span><span class="cov0" title="0">{
                        return ""
                }</span>
                <span class="cov0" title="0">return name</span>
        })

        <span class="cov0" title="0">return &amp;CustomValidator{
                validator: v,
        }</span>
}

// Validate validates a struct
func (cv *CustomValidator) Validate(i interface{}) error <span class="cov0" title="0">{
        err := cv.validator.Struct(i)
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Convert validation errors to a friendly format
        <span class="cov0" title="0">validationErrors := err.(validator.ValidationErrors)
        errorMessages := make([]string, 0, len(validationErrors))

        for _, e := range validationErrors </span><span class="cov0" title="0">{
                errorMessages = append(errorMessages, formatError(e))
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("validation failed: %s", strings.Join(errorMessages, "; "))</span>
}

// formatError formats a validation error
func formatError(err validator.FieldError) string <span class="cov0" title="0">{
        field := err.Field()
        tag := err.Tag()
        param := err.Param()

        switch tag </span>{
        case "required":<span class="cov0" title="0">
                return fmt.Sprintf("%s is required", field)</span>
        case "email":<span class="cov0" title="0">
                return fmt.Sprintf("%s must be a valid email", field)</span>
        case "min":<span class="cov0" title="0">
                return fmt.Sprintf("%s must be at least %s characters", field, param)</span>
        case "max":<span class="cov0" title="0">
                return fmt.Sprintf("%s must be at most %s characters", field, param)</span>
        case "url":<span class="cov0" title="0">
                return fmt.Sprintf("%s must be a valid URL", field)</span>
        case "oneof":<span class="cov0" title="0">
                return fmt.Sprintf("%s must be one of: %s", field, param)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%s failed validation: %s=%s", field, tag, param)</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
